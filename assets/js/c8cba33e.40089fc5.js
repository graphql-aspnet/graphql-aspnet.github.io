"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2053],{5680:(e,t,a)=>{a.d(t,{xA:()=>u,yg:()=>g});var n=a(6540);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(a),h=r,g=d["".concat(s,".").concat(h)]||d[h]||c[h]||i;return a?n.createElement(g,o(o({ref:t},u),{},{components:a})):n.createElement(g,o({ref:t},u))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},8153:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var n=a(8168),r=(a(6540),a(5680));const i={id:"how-it-works",title:"How it Works",sidebar_label:"How it Works",sidebar_position:0},o=void 0,l={unversionedId:"reference/how-it-works",id:"reference/how-it-works",title:"How it Works",description:'This document is a high level overview how GraphQL ASP.NET ultimately generates a response to a query with some insight into core details. Its assumes a working knowledge of both ASP.NET and the GraphQL specification. If you are only interested in the "how" and not the "why", feel free to skip this.',source:"@site/docs/reference/how-it-works.md",sourceDirName:"reference",slug:"/reference/how-it-works",permalink:"/docs/reference/how-it-works",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{id:"how-it-works",title:"How it Works",sidebar_label:"How it Works",sidebar_position:0},sidebar:"tutorialSidebar",previous:{title:"File Uploads & Batching",permalink:"/docs/server-extensions/multipart-requests"},next:{title:"Schema Configuration",permalink:"/docs/reference/schema-configuration"}},s={},p=[{value:"Schema Generation",id:"schema-generation",level:2},{value:"Object Templating",id:"object-templating",level:4},{value:"Middleware Pipelines",id:"middleware-pipelines",level:4},{value:"Query Execution",id:"query-execution",level:2},{value:"Phase 1: Parsing &amp; Validation",id:"phase-1-parsing--validation",level:3},{value:"Phase 2: Execution",id:"phase-2-execution",level:3},{value:"Resolving a Field",id:"resolving-a-field",level:4},{value:"Phase 3: Response Generation",id:"phase-3-response-generation",level:3},{value:"Other Points of Interest",id:"other-points-of-interest",level:2},{value:"Architectural Diagrams",id:"architectural-diagrams",level:2}],u={toc:p};function d(e){let{components:t,...i}=e;return(0,r.yg)("wrapper",(0,n.A)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},'This document is a high level overview how GraphQL ASP.NET ultimately generates a response to a query with some insight into core details. Its assumes a working knowledge of both ASP.NET and the GraphQL specification. If you are only interested in the "how" and not the "why", feel free to skip this.')),(0,r.yg)("h2",{id:"schema-generation"},"Schema Generation"),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"How it Works",src:a(5389).A,width:"1321",height:"399"})),(0,r.yg)("h4",{id:"object-templating"},"Object Templating"),(0,r.yg)("p",null,"When your application starts the runtime begins by inspecting the registered schemas declared in your ",(0,r.yg)("inlineCode",{parentName:"p"},"Startup.cs")," for the different options you've declared and sets off gathering a collection of the possible graph types that may be required."),(0,r.yg)("p",null,"For each type it discovers, it generates a template that describes ",(0,r.yg)("em",{parentName:"p"},"how")," you've asked GraphQL to use your classes. By inspecting declared attributes and the ",(0,r.yg)("inlineCode",{parentName:"p"},"System.Type")," metadata it generates the appropriate information to create everything GraphQL ASP.NET will need to fulfill a query. Information such as input and output parameters for methods, property types, custom type naming, implemented interfaces, union declarations, field path definitions, validation requirements and enforced authorization policies are all gathered and stored at the application level under the globally configured ",(0,r.yg)("inlineCode",{parentName:"p"},"IGraphTypeTemplateProvider"),"."),(0,r.yg)("p",null,"From this collection of metadata, GraphQL then generates the appropriate ",(0,r.yg)("inlineCode",{parentName:"p"},"IGraphType")," objects for each of your schemas based on their individual configurations. By default, this completed a ",(0,r.yg)("inlineCode",{parentName:"p"},"ISchema")," is stored as a singleton in your DI container."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"How does it know what objects to include?")),(0,r.yg)("p",null,"GraphQL ASP.NET has a few methods of determining what objects to include in your schema. By default, it will inspect your application (the entry assembly) for any public classes that inherit from ",(0,r.yg)("inlineCode",{parentName:"p"},"GraphController")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"GraphDirective")," and work from there. It checks every tagged query and mutation method, looks at every return value and every method parameter to find relevant scalars, enums and object types then inspects each one in turn, deeper and deeper down your object chain, to create a full map. It will even inspect the arbitrary C# interfaces implemented on each of your consumed objects. If that interface is ever used as a return type on an action method or a property, its automatically promoted to a graph type and included in the schema."),(0,r.yg)("p",null,"You have complete control of what to include. Be that including additional assemblies, preventing the inclusion of the startup assembly, manually specifying each model class and controller etc. Attributes exist such as ",(0,r.yg)("inlineCode",{parentName:"p"},"[GraphSkip]")," to exclude certain properties, methods or entire classes and limit the scope of the inclusion. On the other side of the fence, you can configure it to only accept classes with an explicitly declared ",(0,r.yg)("inlineCode",{parentName:"p"},"[GraphType]")," attribute, ignoring everything else. And for the most control, disable everything and manually call ",(0,r.yg)("inlineCode",{parentName:"p"},".AddType<T>()")," at startup for each class you want to have in your schema (controllers included). GraphQL will then happily generate declaration errors when it can't find a reference declared in your controllers. This can be an effective technique in spotting data leaks or rogue methods that slipped through a code review. Configure a unit test to generate a schema with different inclusion rules per environment and you now have an automatic CI/CD check in place to give your developers more freedom to write code during a sprint and only have to worry about configurations when submitting a PR."),(0,r.yg)("p",null,"You can even go so far as to add a class to the schema but prevent its publication in introspection queries which can provide some helpful obfuscation. Alternatively, just disable introspection queries altogether. While this does cause client tooling to complain endlessly and makes front-end development much harder; if you and your consumers (like your UI) can agree ahead of time on the query syntax then there is no issue."),(0,r.yg)("h4",{id:"middleware-pipelines"},"Middleware Pipelines"),(0,r.yg)("p",null,"Similar to how ASP.NET utilizes a middleware pipeline to fulfill an HTTP request, GraphQL ASP.NET follows suit to fulfill a graphQL request. Major tasks like validation, parsing, field resolution and result packaging are just ",(0,r.yg)("a",{parentName:"p",href:"../reference/middleware"},"middleware components")," added to a chain of tasks and executed to complete the operation."),(0,r.yg)("p",null,"At the same time as its constructing your schema, GraphQL sets up the 4 primary pipelines and stores them in the DI container as an ",(0,r.yg)("inlineCode",{parentName:"p"},"ISchemaPipeline<TSchema, TContext>"),". Each pipeline can be extended, reworked or completely replaced as needed for your use case."),(0,r.yg)("h2",{id:"query-execution"},"Query Execution"),(0,r.yg)("p",null,"Query execution can be broken down into a series of phaes. For the sake of brevity we've left out the HTTP request steps required to invoke the GraphQL runtime but you can inspect the ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/graphql-aspnet/graphql-aspnet/blob/master/src/graphql-aspnet/Defaults/DefaultGraphQLHttpProcessor%7BTSchema%7D.cs"},"DefaultGraphQLHttpProcessor")," and read through the code. "),(0,r.yg)("p",null,'Note: The concept of a phase here is just for organizing the information, there is no concrete "phase" value managed by the pipelines.'),(0,r.yg)("h3",{id:"phase-1-parsing--validation"},"Phase 1: Parsing & Validation"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp",metastring:'title="HeroController.cs"',title:'"HeroController.cs"'},'public class HeroController : GraphController\n{\n    [QueryRoot("hero")]\n    public Human RetrieveHero(Episode episode)\n    {\n        if(episode == Episode.Empire)\n        {\n            return new Human()\n            {\n                Id = 1000,\n                Name = "Han Solo",\n                HomePlanet = "Corellia",\n            }\n        }\n        else\n        {\n            return new Human()\n            {\n                Id = 1001,\n                Name = "Luke SkyWalker",\n                HomePlanet = "Tatooine",\n            }\n        }\n    }\n}\n')),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-graphql",metastring:'title="Sample Query"',title:'"Sample','Query"':!0},"query {\n    hero(episode: EMPIRE) {\n        name\n        homePlanet\n    }\n}\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-json",metastring:'title="Response JSON"',title:'"Response','JSON"':!0},'{\n    "data" : {\n        "hero": {\n            "name" : "Han Solo",\n            "homePlanet" : "Corellia"\n        }\n    }\n}\n')),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},"Sample query used as a reference example in this section")),(0,r.yg)("p",null,"The supplied query document (top right in the example) is ran through a compilation cycle to ultimately generate an ",(0,r.yg)("inlineCode",{parentName:"p"},"IQueryExecutionPlan"),". It is first lexed into a series of tokens representing the various parts; things like curly braces, colons, strings etc. Then it parses those tokens into a collection of ",(0,r.yg)("inlineCode",{parentName:"p"},"SyntaxNodes")," (creating an Abstract Syntax Tree) representing concepts like ",(0,r.yg)("inlineCode",{parentName:"p"},"FieldNode"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"InputValueNode"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"OperationTypeNode")," following the ",(0,r.yg)("a",{parentName:"p",href:"https://spec.graphql.org/October2021/#sec-Source-Text"},"graphql specification rules for source text documents"),"."),(0,r.yg)("p",null,"Once parsed, the runtime will execute its internal rules engine against the generated ",(0,r.yg)("inlineCode",{parentName:"p"},"ISyntaxTree"),", using the targeted ",(0,r.yg)("inlineCode",{parentName:"p"},"ISchema"),", to create a query plan where it marries the nodes AST with concrete structures such as controllers, action methods and POCOs. It is at this stage where the ",(0,r.yg)("inlineCode",{parentName:"p"},"hero")," field in the example is matched to the ",(0,r.yg)("inlineCode",{parentName:"p"},"HeroController")," with its appropriate ",(0,r.yg)("inlineCode",{parentName:"p"},"IGraphFieldResolver")," to invoke the ",(0,r.yg)("inlineCode",{parentName:"p"},"RetrieveHero")," action method."),(0,r.yg)("p",null,"While generating a query plan the rules engine will do its best to complete an analysis of the entire document and return to the requestor every error it finds. Depending on the errors though, it may or may not be able to catch them all. For instance, a syntax error, like a missing ",(0,r.yg)("inlineCode",{parentName:"p"},"}"),", will preclude generating a query plan so errors centered around invalid field names or a type expression mismatch won't be caught until the syntax error is fixed (just like any other compiler)."),(0,r.yg)("h3",{id:"phase-2-execution"},"Phase 2: Execution"),(0,r.yg)("p",null,"The engine now has a completed query plan that describes:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The named operation in the document to be executed (or the single anonymous operation in the example above)"),(0,r.yg)("li",{parentName:"ul"},"The top level fields and every child field on the chosen operation.")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Its successfully validated that:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"All the referenced fields for the graph types exist and are valid where requested"),(0,r.yg)("li",{parentName:"ul"},'Required input arguments have been supplied and their data is "resolvable"',(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"This just means that we've validated that a number is a number, named fields on input objects exist etc.")))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"For each field, the runtime will:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Substitute any deferred input arguments with referenced variable data"),(0,r.yg)("li",{parentName:"ul"},"Generate a field execution context containing the necessary data about the source data, arguments and resolver."),(0,r.yg)("li",{parentName:"ul"},"Authenticate the user to the field."),(0,r.yg)("li",{parentName:"ul"},"Execute the resolver to fetch a data value."),(0,r.yg)("li",{parentName:"ul"},"Invoke any child fields requested.")),(0,r.yg)("h4",{id:"resolving-a-field"},"Resolving a Field"),(0,r.yg)("p",null,'GraphQL uses the phrase "resolver" to describe a method that, for a given field, takes in parameters and generates a result.'),(0,r.yg)("p",null,"At startup, GraphQL ASP.NET automatically creates resolver references for your controller methods, POCO properties and tagged POCO methods. These are nothing more than delegates for method invocations; for properties it uses the getter registered with ",(0,r.yg)("inlineCode",{parentName:"p"},"PropertyInfo"),"."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("em",{parentName:"strong"},"Performance Note")),": The library makes heavy use of compiled Expression Trees to call its resolvers and for instantiating input objects. As a result, its many orders of magnitude faster than baseline reflected calls and nearly as performant as precompiled code.")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Concerning Proxy Libraries (e.g. EF Core Proxies)")),(0,r.yg)("p",null,"GraphQL ASP.NET natively supports Liskov substitutions for all graph types opening up the possibility for using libraries such as EF Proxies that can provide a tremendously powerful and easy to setup graph structure. By lazy loading any child collections you can expose access to your entire domain model with very little work."),(0,r.yg)("p",null,"Be careful though, ",(0,r.yg)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/ef/core/querying/related-data/lazy"},"EF Core Proxies")," and like libraries suffer from the same N + 1 problem as GraphQL libraries do. By choosing to use such lazy loading techniques you are circumventing GraphQL ASP.NET's provided mechanisms for handling such situations and need to be exceptionally careful to manage the issue yourself."),(0,r.yg)("h3",{id:"phase-3-response-generation"},"Phase 3: Response Generation"),(0,r.yg)("p",null,"Once all fields have been processed the runtime makes a final pass to propagate any nullability errors up the field chain resulting in a final data set. This data set is then passed to the ",(0,r.yg)("inlineCode",{parentName:"p"},"IGraphResponseWriter")," registered for the schema and the result is serialized to the HttpResponse."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Writing a response includes:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Serializing the ",(0,r.yg)("inlineCode",{parentName:"p"},"errors")," generated during execution"),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"All error messages have a severity level. Your schema configuration controls which are sent to the client."),(0,r.yg)("li",{parentName:"ul"},"You can add your own error messages through your controller actions by returning ",(0,r.yg)("inlineCode",{parentName:"li"},"this.Error()"),"."),(0,r.yg)("li",{parentName:"ul"},"Error messages may or may not have associated exception data which may or may not be exposed to the client depending on who they are or the schema configuration settings."))),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Serializing the ",(0,r.yg)("inlineCode",{parentName:"p"},"data")," field to the response stream")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Serializing the ",(0,r.yg)("inlineCode",{parentName:"p"},"extensions")," field (such as metrics data) to the response stream"))),(0,r.yg)("h2",{id:"other-points-of-interest"},"Other Points of Interest"),(0,r.yg)("p",null,"Hopefully we've given you a bit of insight into how the library works under the hood. The other documents on this site go into exhaustive detail of the different features and how to use them but since you're here:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The library targets ",(0,r.yg)("a",{parentName:"li",href:"https://docs.microsoft.com/en-us/dotnet/standard/net-standard"},(0,r.yg)("inlineCode",{parentName:"a"},"netstandard2.0"))," and ",(0,r.yg)("inlineCode",{parentName:"li"},"net6.0"),".",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Out of the box there are no external dependencies beyond official Microsoft packages.")))),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Every core component and all ",(0,r.yg)("a",{parentName:"p",href:"/docs/reference/middleware"},"middleware components")," required to complete the tasks outlined in this document are referenced through dependency injection. Any one of them (or all of them) can be overridden and extended to do whatever you want as long as you register them prior to calling ",(0,r.yg)("inlineCode",{parentName:"p"},".AddGraphQL()")," at startup."),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Inject your own ",(0,r.yg)("inlineCode",{parentName:"li"},"IGraphResponseWriter")," to serialize your results to XML or CSV."),(0,r.yg)("li",{parentName:"ul"},"Build your own ",(0,r.yg)("inlineCode",{parentName:"li"},"IOperationComplexityCalculator")," to intercept and alter how a query plan generates its ",(0,r.yg)("a",{parentName:"li",href:"../execution/malicious-queries"},"complexity values")," to be more suitable to your needs."),(0,r.yg)("li",{parentName:"ul"},"On and on and on...")))),(0,r.yg)("h2",{id:"architectural-diagrams"},"Architectural Diagrams"),(0,r.yg)("p",null,"\ud83d\udccc ",(0,r.yg)("a",{target:"_blank",href:a(1220).A},"Structural Diagrams")),(0,r.yg)("p",null,"A set of diagrams outlining the major interfaces and classes that make up GraphQL Asp.Net."),(0,r.yg)("p",null,"\ud83d\udccc ",(0,r.yg)("a",{target:"_blank",href:a(9581).A},"Execution Diagrams")),(0,r.yg)("p",null,"A set of flowcharts and relational diagrams showing how various aspects of the library fit together at run time, including the query execution and field execution pipelines."))}d.isMDXComponent=!0},9581:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/files/2022-10-graphql-aspnet-execution-diagrams-82ed1c157484c18822b05a009f20768d.pdf"},1220:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/files/2022-10-graphql-aspnet-structural-diagrams-2ce89a3328b83ac31eb4dac13986550a.pdf"},5389:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/how-it-works-1-8cf26d6348f0ddb7a1e9d22117fa3045.png"}}]);