"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[657],{4373:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"advanced/type-expressions","title":"Type Expressions","description":"The GraphQL specification states that when a field resolves a value that doesn\'t conform to the expected type expression of the field that the value is rejected, converted to null and an error added to the response.","source":"@site/docs/advanced/type-expressions.md","sourceDirName":"advanced","slug":"/advanced/type-expressions","permalink":"/docs/advanced/type-expressions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"type-expressions","title":"Type Expressions","sidebar_label":"Type Expressions","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Subscriptions","permalink":"/docs/advanced/subscriptions"},"next":{"title":"Directives","permalink":"/docs/advanced/directives"}}');var s=t(4848),r=t(8453);const l={id:"type-expressions",title:"Type Expressions",sidebar_label:"Type Expressions",sidebar_position:1},a=void 0,o={},d=[{value:"Field Type Expressions",id:"field-type-expressions",level:2},{value:"Input Argument Type Expressions",id:"input-argument-type-expressions",level:2},{value:"Runtime Type Validation",id:"runtime-type-validation",level:2}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"The GraphQL specification states that when a field resolves a value that doesn't conform to the expected type expression of the field that the value is rejected, converted to null and an error added to the response."}),"\n",(0,s.jsx)(n.p,{children:"When the library builds a schema it makes as few assumptions as possible about the data returned from your fields to result in as few errors as possible."}),"\n",(0,s.jsx)(n.p,{children:"These assumptions are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Fields that return reference types ",(0,s.jsx)(n.strong,{children:"can be"})," null"]}),"\n",(0,s.jsxs)(n.li,{children:["Fields that return primatives or value types (including structs) ",(0,s.jsx)(n.strong,{children:"cannot be"})," null"]}),"\n",(0,s.jsxs)(n.li,{children:["Fields that return Nullable primatives or value types (e.g. ",(0,s.jsx)(n.code,{children:"int?"}),") ",(0,s.jsx)(n.strong,{children:"can be"})," be null."]}),"\n",(0,s.jsxs)(n.li,{children:["When a field returns an object that implements ",(0,s.jsx)(n.code,{children:"IEnumerable<TType>"}),' it will be presented to GraphQL as a "list of ',(0,s.jsx)(n.code,{children:"TType"}),'".']}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Basically, if your method is able to return a value...then its valid as far as GraphQL is concerned."}),"\n",(0,s.jsx)(n.p,{children:"Lets look at an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="BakeryController.cs"',children:'[GraphRoute("bakery")]\npublic class BakeryController : GraphController\n{\n    [Query("donut")]\n    public Donut RetrieveDonut(int id)\n    {/*...*/}\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Sample Query"',children:"query {\n    bakery {\n        donut(id: 15){\n            name\n            flavor\n        }\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Assuming ",(0,s.jsx)(n.code,{children:"Donut"})," was a class (a reference type), this action method could return a donut object or ",(0,s.jsx)(n.code,{children:"null"}),". But should the donut field, from a GraphQL perspective, allow a null return value? The code certainly does and the rules above say fields that return a reference type can be null...but that's not what's important. Its ultimately your decision to decide if a \"null donut\" is allowed, not the C# compiler and not the assumptions made by the library."]}),"\n",(0,s.jsxs)(n.p,{children:["On one hand, if a null value is returned, regardless of it being valid, the ",(0,s.jsx)(n.em,{children:"outcome"})," of the field is the same. When we return a null no child fields are processed. On the other hand, if null is not allowed we need to tell someone, let them know its nulled out not because it simply ",(0,s.jsx)(n.em,{children:"is"})," null but because a schema violation occurred."]}),"\n",(0,s.jsx)(n.h2,{id:"field-type-expressions",children:"Field Type Expressions"}),"\n",(0,s.jsxs)(n.p,{children:["You can add more specificity to your fields by using the ",(0,s.jsx)(n.code,{children:"TypeExpression"})," property of the various field declaration attributes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Example Custom Type Expressions"',children:'// Declare that a donut MUST be returned (null is invalid)\n// ----\n// Final Schema Syntax:  Donut!\n// highlight-next-line\n[Query("donut", TypeExpression = "Type!")]\npublic Donut RetrieveDonut(string id)\n{/*...*/}\n\n\n// Declare that a list must be returned but the elements of the list\n// could be null:\n// valid:    [donut1, null, donut2, donut3]\n// valid:    []\n// invalid:  null\n// ----\n// Final Schema Syntax:  [Donut]!\n// highlight-next-line\n[Query("donut", TypeExpression = "[Type]!")]\npublic IEnumerable<Donut> RetrieveDonut(string id)\n{/*...*/}\n\n\n// Declare that a list must be returned AND the elements of the list\n// must not be null:\n// valid:    [donut1, donut2, donut3]\n// valid:    []\n// invalid:  [donut1, null, donut2]\n// invalid:  null\n// ----\n// Final Schema Syntax:  [Donut!]!\n// highlight-next-line\n[Query("donut", TypeExpression = "[Type!]!")]\npublic IEnumerable<Donut> RetrieveDonut(string id)\n{/*...*/}\n'})}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.mdxAdmonitionTitle,{children:[(0,s.jsx)(n.code,{children:"Type"})," is a place holder"]}),(0,s.jsxs)(n.p,{children:["The type name used in the examples (e.g. ",(0,s.jsx)(n.code,{children:"Type"}),") is arbitrary and can be any valid string. The correct type name for the target field will be used in its place at runtime."]})]}),"\n",(0,s.jsx)(n.h2,{id:"input-argument-type-expressions",children:"Input Argument Type Expressions"}),"\n",(0,s.jsxs)(n.p,{children:["Similar to fields, you can use the ",(0,s.jsx)(n.code,{children:"TypeExpression"})," property on ",(0,s.jsx)(n.code,{children:"[FromGraphQL]"})," to add more specificity to your input arguments."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Type Expression on an Argument"',children:'// Force the argument "id" to supply a string (it cannot be supplied as null)\n// -----------------\n// Final Type Expression of the \'id\' arg:  String!\n[Query]\n// highlight-next-line\npublic Donut RetrieveDonut([FromGraphQL(TypeExpression = "Type!")] string id)\n{/*...*/}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"runtime-type-validation",children:"Runtime Type Validation"}),"\n",(0,s.jsx)(n.p,{children:"Note that the library will accept your type string even if it would be impossible, from a C# perspective, to return data that would match."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Data and Type Expression Mismatch"',children:'// QUERY EXECUTION ERROR\n// GraphQL will attempt to process a single Donut as a list and will fail\n// highlight-next-line\n[Query("donut", TypeExpression ="[Type]")]\npublic Donut RetrieveDonut(string id)\n{/*...*/}\n'})}),"\n",(0,s.jsx)(n.p,{children:"When executing a query and resolving a field, should one of your action methods (or even your object properties) not return data conforming to the type expression that's defined for it, GraphQL will reject the data. The value is set to null and an error is registered in the response for the field in question. The runtime will not attempt to resolve any referenced child fields for a rejected value."}),"\n",(0,s.jsxs)(n.p,{children:["If the rejected field does not allow nulls, the error is propagated up to its parent, which is then also set to null. If that parent field can't return a null value the error continues up until it reaches a field that can be null or the entire field collection is nulled out. [Spec \xa7 ",(0,s.jsx)(n.a,{href:"https://graphql.github.io/graphql-spec/October2021/#sec-Errors-and-Non-Nullability",children:"6.4.4"}),"]"]}),"\n",(0,s.jsxs)(n.admonition,{type:"danger",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsxs)(n.p,{children:["When declared, the runtime will use your ",(0,s.jsx)(n.code,{children:"TypeExpression"})," as law for any field declarations; skipping its internal checks. You can setup a scenario where by you could return data that the runtime could never validate as being correct and GraphQL will happily process it and return an error every time."]})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:'"With great power comes great responsibility"  -Uncle Ben'}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function l(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);