"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[3603],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(6540);const s={},l=i.createContext(s);function a(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(l.Provider,{value:n},e.children)}},9016:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"types/input-objects","title":"Input Objects","description":"INPUTOBJECT graph types (a.k.a. input objects) represent complex data supplied to arguments on fields or directives. Anytime you want to pass more data than a single string or a number, perhaps an Address or a new Employee record, you use an INPUTOBJECT to represent that entity in GraphQL.  When the system scans your controllers, if it comes across a class or struct used as a parameter to a method it will attempt to generate the appropriate input type definition to represent that class.","source":"@site/docs/types/input-objects.md","sourceDirName":"types","slug":"/types/input-objects","permalink":"/docs/types/input-objects","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"input-objects","title":"Input Objects","sidebar_label":"Input Objects","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Objects","permalink":"/docs/types/objects"},"next":{"title":"Interfaces","permalink":"/docs/types/interfaces"}}');var s=t(4848),l=t(8453);const a={id:"input-objects",title:"Input Objects",sidebar_label:"Input Objects",sidebar_position:1},r=void 0,o={},c=[{value:"Customized Type Names",id:"customized-type-names",level:2},{value:"Use an Empty Constructor",id:"use-an-empty-constructor",level:2},{value:"Properties Must Have a Public Setter",id:"properties-must-have-a-public-setter",level:2},{value:"Methods are Ignored",id:"methods-are-ignored",level:2},{value:"Non-Nullability",id:"non-nullability",level:2},{value:"Required Fields And Default Values",id:"required-fields-and-default-values",level:2},{value:"Nullable Fields are Never Required",id:"nullable-fields-are-never-required",level:3},{value:"Required Reference Types",id:"required-reference-types",level:3},{value:"Enum Fields and Coercability",id:"enum-fields-and-coercability",level:2},{value:"Input Unions / @oneOf",id:"input-unions--oneof",level:2}];function u(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"INPUT_OBJECT"})," graph types (a.k.a. input objects) represent complex data supplied to arguments on fields or directives. Anytime you want to pass more data than a single string or a number, perhaps an Address or a new Employee record, you use an INPUT_OBJECT to represent that entity in GraphQL.  When the system scans your controllers, if it comes across a class or struct used as a parameter to a method it will attempt to generate the appropriate input type definition to represent that class."]}),"\n",(0,s.jsxs)(n.p,{children:["The rules surrounding naming, field declarations, exclusions, use of ",(0,s.jsx)(n.code,{children:"[GraphSkip]"})," etc. apply to input objects but with a few key differences:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Unless overridden, an input object is named the same as its class name, prefixed with ",(0,s.jsx)(n.code,{children:"Input_"})," (e.g. ",(0,s.jsx)(n.code,{children:"Input_Address"}),", ",(0,s.jsx)(n.code,{children:"Input_Employee"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Only public properties with a ",(0,s.jsx)(n.code,{children:"get"})," and ",(0,s.jsx)(n.code,{children:"set"})," will be included.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Property return types cannot be ",(0,s.jsx)(n.code,{children:"Task<T>"}),", an ",(0,s.jsx)(n.code,{children:"interface"})," and cannot implement ",(0,s.jsx)(n.code,{children:"IGraphUnionProxy"})," or ",(0,s.jsx)(n.code,{children:"IGraphActionResult"}),". Such properties are always skipped."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Methods are always skipped."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"customized-type-names",children:"Customized Type Names"}),"\n",(0,s.jsxs)(n.p,{children:["Input objects can be given customized names, just like with object types, using the ",(0,s.jsx)(n.code,{children:"[GraphType]"})," attribute."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Customized Input Object Type Name"',children:'[GraphType(InputName = "NewDonutModel")]\npublic class Donut\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public DonutType Type { get; set; }\n    public decimal Price { get; set; }\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Donut Type Definition"',children:"input NewDonutModel {\n  id: Int! = 0\n  name: String = null\n  type: DonutType! = FROSTED\n  price: Decimal! = 0\n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Note the specific callout to ",(0,s.jsx)(n.code,{children:"InputName"})," in the attribution."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"use-an-empty-constructor",children:"Use an Empty Constructor"}),"\n",(0,s.jsx)(n.p,{children:"When GraphQL executes a query it will attempt to create an instance of your input object then assign the key/value pairs received on the query to the properties. In order to do the initial instantiation it requires a public parameterless constructor to do so."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Input Objects MUST have a Public, Parameterless Constructor',children:'public class BakeryController : GraphController\n{\n    [Mutation("createDonut")]\n    public bool CreateNewDonut(DonutModel donut)\n    {/*....*/}\n}\n\n// DonutModel.cs\npublic class DonutModel\n{\n    //Use a public parameterless constructor\n    public DonutModel()\n    {\n    }\n\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:['Because of this consturctor restriction it can be helpful to separate your classes between "input" and "output" types much is the same way we do with ',(0,s.jsx)(n.code,{children:"ViewModel"})," vs. ",(0,s.jsx)(n.code,{children:"BindingModel"})," objects with REST queries in ASP.NET. This is optional, mix and match as needed by your use case."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"properties-must-have-a-public-setter",children:"Properties Must Have a Public Setter"}),"\n",(0,s.jsx)(n.p,{children:"Properties without a setter are ignored. At runtime, GraphQL compiles an expression tree with the set assignments declared on the graph type, it won't attempt to sneakily reflect and invoke a private or protected setter."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Properties must Have a Public Setter"',children:"public class Donut\n{\n    public int Id { get; }\n    public string Name { get; set; }\n    public DonutType Type { get; set; }\n    public decimal Price { get; set; }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Donut Type Definition"',children:"# Id field is not included \n\ninput Input_Donut {\n  name: String = null\n  type: DonutType! = FROSTED\n  price: Decimal! = 0\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"methods-are-ignored",children:"Methods are Ignored"}),"\n",(0,s.jsxs)(n.p,{children:["While its possible to have methods be exposed as resolvable fields on regular ",(0,s.jsx)(n.code,{children:"OBJECT"})," types, they are ignored for input types regardless of the declaration rules applied to the type."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Methods Are Ignored on Input Objects"',children:'public class Donut\n{\n    [GraphField("salesTax")]\n    public decimal CalculateSalesTax(decimal taxPercentage)\n    {\n        return this.Price * taxPercentage;\n    }\n\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public DonutType Type { get; set; }\n    public decimal Price { get; set; }\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Donut Type Definition"',children:"# CalculateSalesTax is not included\ninput Input_Donut {\n  id: Int! = 0\n  name: String = null\n  type: DonutType! = FROSTED\n  price: Decimal! = 0\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"non-nullability",children:"Non-Nullability"}),"\n",(0,s.jsx)(n.p,{children:"By default, all properties that are reference types (i.e. classes) are nullable and all value types (primatives, structs etc.) are non-nullable"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Recipe can be null, it is a reference type"',children:"public class Donut\n{\n    public Recipe Recipe { get; set; }  // reference type\n    public int Quantity { get; set; }   // value type\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Input Donut Definition"',children:"input Input_Donut {\n  recipe: Input_Recipe = null  # nullable\n  quantity: Int! = 0           # not nullable\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you want to force a reference type to be non-null you can use the ",(0,s.jsx)(n.code,{children:"[GraphField]"})," attribute to augment the field's type expression."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Force Recipe to be non-null"',children:'public class Donut\n{\n    public Donut()\n    {\n        // we must supply a non-null default value \n        // for a non-nullable field\n        this.Recipe = new Recipe("Flour, Sugar, Salt");\n    }\n\n    [GraphField(TypeExpression = "Type!")]\n    public Recipe Recipe { get; set; }  // reference type\n    public int Quantity { get; set; }   // value type\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Input Donut Definition"',children:'input Input_Donut {\n  recipe: Input_Recipe! = {ingredients : "Flour, Sugar, Salt" }  \n  quantity: Int! = 0                   \n}\n'})}),"\n",(0,s.jsxs)(n.admonition,{title:"Did You Notice?",type:"info",children:[(0,s.jsx)(n.p,{children:"We assigned a recipe in the class's constructor to use as the default value."}),(0,s.jsxs)(n.p,{children:["Any non-nullable field, that does not have the ",(0,s.jsx)(n.code,{children:"[Required]"})," attribute (see below), MUST have a default value assigned to it that is not ",(0,s.jsx)(n.code,{children:"null"}),". A ",(0,s.jsx)(n.code,{children:"GraphTypeDeclarationException"})," will be thrown at startup if this is not the case."]})]}),"\n",(0,s.jsx)(n.h2,{id:"required-fields-and-default-values",children:"Required Fields And Default Values"}),"\n",(0,s.jsxs)(n.p,{children:["Add ",(0,s.jsx)(n.code,{children:"[Required]"})," (from System.ComponentModel) to any property to force a user to supply the field in a query document."]}),"\n",(0,s.jsx)(n.p,{children:"Any non-required field will automatically be assigned a default value if not supplied on a query. This default value is equivilant to the property value of the object when its instantiated via its public, parameterless constructor."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Add the Required attribute for force a query to define a value"',children:"public class Donut\n{\n    public Donut()\n    {\n        // set custom defaults if needed\n        this.Type = DonutType.Frosted;\n        this.IsAvailable = true;\n    }    \n    \n    [Required]\n    public int Id { get; set; }\n\n    public string Name { get; set; }\n    public DonutType Type { get; set; }\n    public Bakery Bakery { get;set; }   \n    public bool IsAvailable { get; set; }\n    public int SkuNumber { get; set; }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Donut Type Definition"',children:"input Input_Donut {\n  id: Int!   # No Default Value on Id\n  name: String = null    \n  type: DonutType! = FROSTED\n  bakery: Input_Bakery = null\n  isAvailable: Boolean! = true\n  skuNumber: Int! = 0\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"nullable-fields-are-never-required",children:"Nullable Fields are Never Required"}),"\n",(0,s.jsxs)(n.p,{children:["By Definition (spec \xa7 ",(0,s.jsx)(n.a,{href:"https://spec.graphql.org/October2021/#sec-Input-Object-Required-Fields",children:"5.6.4"}),"), a nullable field without a\ndeclared default value is still considered optional and does not need to be supplied.  That is to say that if a query does not include a field that is nullable, it will default to ",(0,s.jsx)(n.code,{children:"null"})," regardless of the use of the ",(0,s.jsx)(n.code,{children:"[Required]"})," attribute."]}),"\n",(0,s.jsx)(n.p,{children:"These two property declarations for an input object are identical as far as graphql is concerned:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:"title='Example Input object Fields'",children:"public InputEmployee\n{\n    public string  FirstName { get; set; }\n\n    [Required]\n    public string LastName { get; set; }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Both ",(0,s.jsx)(n.code,{children:"FirstName"})," and ",(0,s.jsx)(n.code,{children:"LastName"})," are of type ",(0,s.jsx)(n.code,{children:"string"}),", which is nullable.  GraphQL will ignore the required attribute and still allow a query to process even if neither value is supplied on a query."]}),"\n",(0,s.jsx)(n.h3,{id:"required-reference-types",children:"Required Reference Types"}),"\n",(0,s.jsx)(n.p,{children:"Combine the [Required] attribute with a non-nullable type expression to force an otherwise nullable field to be required."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Force Owner to be non-null And Required"',children:'public class Bakery\n{\n    [Required]\n    [GraphField(TypeExpression = "Type!")]\n    public Person Owner { get; set; }\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Donut Type Definition"',children:"# No Default Value is supplied. \n# the 'owner' must be supplied on a query\ninput Input_Bakery {\n  owner: Input_Person!\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Owner"})," is of type Person, which is a reference type, which is nullable by default.  By augmenting its type expression to be non-null and adding the ",(0,s.jsx)(n.code,{children:"[Required]"})," attribute graphql will not supply a default value require it to be supplied on a query."]}),"\n",(0,s.jsx)(n.h2,{id:"enum-fields-and-coercability",children:"Enum Fields and Coercability"}),"\n",(0,s.jsx)(n.p,{children:"Any default value declared for an input field must be coercible by its target graph type in the target schema. Because of this there is a small got'cha situation with enum values."}),"\n",(0,s.jsx)(n.p,{children:"Take a look at this example of an enum and input object:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Using an Enum as a field type"',children:"public class Donut \n{\n    public string Name { get; set; }\n    public DonutFlavor Flavor { get; set; }\n}\n\npublic enum DonutFlavor\n{\n    [GraphSkip]\n    Vanilla = 0,\n    Chocolate = 1,\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"Donut"})," is instantiated the value of Flavor will be ",(0,s.jsx)(n.code,{children:"Vanilla"})," because\nthats the default value (0) of the enum. However, the enum value ",(0,s.jsx)(n.code,{children:"Vanilla"})," is marked as being skipped in the schema."]}),"\n",(0,s.jsxs)(n.p,{children:["Because of this mismatch, a ",(0,s.jsx)(n.code,{children:"GraphTypeDeclarationException"})," will be thrown when the introspection data for your schema is built. As a result, the server will fail to start until the problem is corrected."]}),"\n",(0,s.jsx)(n.p,{children:"You can get around this by setting an included enum value in the consturctor:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="Using an Enum as a field type"',children:"public class Donut \n{\n    public Donut()\n    {\n        // set the value of flavor to an enum value \n        // included in the graph\n        this.Flavor = DonutFlavor.Chocolate;\n    }\n\n    public string Name { get; set; }\n    public DonutFlavor Flavor { get; set; }\n}\n\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsx)(n.p,{children:"Enum values used for the default value of input object properties MUST also exist as values in the schema or an exception will be thrown."})}),"\n",(0,s.jsx)(n.h2,{id:"input-unions--oneof",children:"Input Unions / @oneOf"}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/advanced/input-unions",children:"Input Unions"})," in the advanced section for details on using the ",(0,s.jsx)(n.code,{children:"@oneOf"})," directive."]})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);