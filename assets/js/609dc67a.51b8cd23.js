"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[61],{1210:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"controllers/batch-operations","title":"Batch Operations","description":"Read the section on type extensions before reading this document. Batch Operations expand on type extensions and understanding how they work is critical.","source":"@site/docs/controllers/batch-operations.md","sourceDirName":"controllers","slug":"/controllers/batch-operations","permalink":"/docs/controllers/batch-operations","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"batch-operations","title":"Batch Operations","sidebar_label":"Batch Operations","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Type Extensions","permalink":"/docs/controllers/type-extensions"},"next":{"title":"Objects","permalink":"/docs/types/objects"}}');var i=r(4848),a=r(8453);const s={id:"batch-operations",title:"Batch Operations",sidebar_label:"Batch Operations",sidebar_position:5},o=void 0,l={},d=[{value:"The N+1 Problem",id:"the-n1-problem",level:2},{value:"[BatchTypeExtension] Attribute",id:"batchtypeextension-attribute",level:2},{value:"Data Loaders",id:"data-loaders",level:2},{value:"Returning Data",id:"returning-data",level:2},{value:"Returning <code>IDictionary&lt;TSource, TValue&gt;</code>",id:"returning-idictionarytsource-tvalue",level:4},{value:"Other Resources",id:"other-resources",level:2}];function c(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h4:"h4",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.admonition,{type:"caution",children:[(0,i.jsx)(t.mdxAdmonitionTitle,{}),(0,i.jsxs)(t.p,{children:["Read the section on ",(0,i.jsx)(t.a,{href:"./type-extensions",children:"type extensions"})," before reading this document. Batch Operations expand on type extensions and understanding how they work is critical."]})]}),"\n",(0,i.jsx)(t.h2,{id:"the-n1-problem",children:"The N+1 Problem"}),"\n",(0,i.jsxs)(t.p,{children:["There are plenty of articles on the web discussing the theory behind the N+1 problem (",(0,i.jsx)(t.a,{href:"./batch-operations#other-resources",children:"links below"}),"). Instead, we'll jump into an example to illustrate the issue when it comes to GraphQL."]}),"\n",(0,i.jsxs)(t.p,{children:["Let's build on our example from the discussion on type extensions where we created an extension to retrieve ",(0,i.jsx)(t.code,{children:"Cake Orders"})," for a ",(0,i.jsx)(t.strong,{children:"single"})," ",(0,i.jsx)(t.code,{children:"Bakery"}),". What if we're a national chain and need to see the last 50 orders for each of our stores in a region? This seems like a reasonable thing an auditor would do so lets alter our controller to fetch all our bakeries and then let our type extension fetch the cake orders."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="Retrieving Multiple Bakeries"',children:'public class Bakery\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n\npublic class BakedGoodsCompanyController : GraphController\n{\n    [QueryRoot("bakeries")]\n    // highlight-next-line\n    public async Task<List<Bakery>> RetrieveBakeries(Regions region = Regions.All)\n    {/*...*/}\n\n    // retrieve the cake orders for a single bakery\n    [TypeExtension(typeof(Bakery), "orders")]\n    public async Task<List<CakeOrder>> RetrieveCakeOrders(Bakery bakery, int limitTo = 15){\n\n        return await _service.RetrieveCakeOrders(bakery.Id, limitTo);\n    }\n}\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-graphql",metastring:'title="Sample Query"',children:"query {\n    bakeries(region: SOUTH_WEST){\n        name\n        orders(limitTo: 50) {\n            id\n            writtenPhrase\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Well that was easy, right? Not so fast!"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"bakeries"})," field returns a ",(0,i.jsx)(t.code,{children:"List<Bakery>"})," but the ",(0,i.jsx)(t.code,{children:"RetrieveCakeOrders"})," method takes in a single ",(0,i.jsx)(t.code,{children:"Bakery"}),". GraphQL will, ",(0,i.jsx)(t.strong,{children:"for each bakery retrieved"}),", execute the ",(0,i.jsx)(t.code,{children:"orders"})," field to retrieve its orders. If ",(0,i.jsx)(t.code,{children:"bakeries"})," retrieved 50 stores in the south west region, graphql will execute ",(0,i.jsx)(t.code,{children:"RetrieveCakeOrders"})," 50 times, which will execute 50 database queries."]}),"\n",(0,i.jsxs)(t.p,{children:["This is the N+1 problem. ",(0,i.jsx)(t.code,{children:"1 query"})," for the bakeries + ",(0,i.jsx)(t.code,{children:"N queries"})," for the cake orders, where N is the number of bakeries first retrieved."]}),"\n",(0,i.jsxs)(t.p,{children:["If only we could batch the request and fetch all the cake orders for all the bakeries at once, then assign the ",(0,i.jsx)(t.code,{children:"Cake Orders"})," back to their respective bakeries, we'd be a lot better off. No matter the number of bakeries retrieved, we'd execute 2 queries; 1 for ",(0,i.jsx)(t.code,{children:"bakeries"})," and 1 for ",(0,i.jsx)(t.code,{children:"orders"}),".This is where batch extensions come in to play."]}),"\n",(0,i.jsx)(t.h2,{id:"batchtypeextension-attribute",children:"[BatchTypeExtension] Attribute"}),"\n",(0,i.jsxs)(t.p,{children:["A batch operation is implemented as a type extension but with the word ",(0,i.jsx)(t.code,{children:"Batch"})," in it. Lets look at an example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="A Batch Type Extension"',children:'public class BakedGoodsCompanyController : GraphController\n{\n    [QueryRoot("bakeries")]\n    public async Task<List<Bakery>> RetrieveBakeries(Region region){/*...*/}\n\n    // declare the batch operation as an extension\n    // highlight-next-line\n    [BatchTypeExtension(typeof(Bakery), "orders", typeof(List<CakeOrder>))]\n    public async Task<IGraphActionResult> RetrieveCakeOrders(\n        IEnumerable<Bakery> bakeries,\n        int limitTo = 15)\n    {\n        //fetch all the orders at once\n        var allOrders = await _service.RetrieveCakeOrders(bakeries.Select(x => x.Id), limitTo);\n\n        // return the batch of orders\n        // highlight-start\n        return this.StartBatch()\n            .FromSource(bakeries, bakery => bakery.Id)\n            .WithResults(allOrders, cakeOrder => cakeOrder.BakeryId)\n            .Complete();\n        // highlight-end\n    }\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Key things to notice:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["We've used ",(0,i.jsx)(t.code,{children:"[BatchTypeExtension]"})," instead of ",(0,i.jsx)(t.code,{children:"[TypeExtension]"})]}),"\n",(0,i.jsxs)(t.li,{children:["The method takes in an ",(0,i.jsx)(t.code,{children:"IEnumerable<Bakery>"})," instead of a single ",(0,i.jsx)(t.code,{children:"Bakery"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["The method returns an action result created from ",(0,i.jsx)(t.code,{children:"this.StartBatch()"})]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The contents of your extension method is going to vary widely from use case to use case. Here we've forwarded the ids of the bakeries to a service to fetch the orders. The important take away is that ",(0,i.jsx)(t.code,{children:"RetrieveCakeOrders"})," is now called only once, regardless of how many items are in the ",(0,i.jsx)(t.code,{children:"IEnumerable<Bakery>"})," parameter."]}),"\n",(0,i.jsx)(t.h2,{id:"data-loaders",children:"Data Loaders"}),"\n",(0,i.jsxs)(t.p,{children:["You'll often hear the term ",(0,i.jsx)(t.code,{children:"Data Loaders"})," when reading about GraphQL implementations. Methods that load the child data being requested as a single operation before assigning that data to each of the parents. There is no difference with GraphQL ASP.NET. You still have to write that method. But with the ability to capture action method parameters and clever use of an ",(0,i.jsx)(t.code,{children:"IGraphActionResult"})," we can combine the data load phase with the assignment phase into a single batch operation, at least on the surface. The aim is to make it easy to read and easier to write."]}),"\n",(0,i.jsx)(t.h2,{id:"returning-data",children:"Returning Data"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"this.StartBatch()"})," returns a builder to define how you want GraphQL to construct your batch. We need to tell it how each of the child items we fetched maps to the parents that were supplied (if at all)."]}),"\n",(0,i.jsxs)(t.p,{children:["In the example, we matched on a bakery's primary key selecting ",(0,i.jsx)(t.code,{children:"Bakery.Id"})," from each of the source items and pairing it against ",(0,i.jsx)(t.code,{children:"CakeOrder.BakeryId"})," from each of the results. This is enough information for the builder to generate a valid result. Depending on the contents of your data and the type expression of your extension there are few scenarios that emerge:"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"1 Source -> 1 Result"})}),"\n",(0,i.jsxs)(t.p,{children:["If you've defined your extension field to be a single item (i.e. ",(0,i.jsx)(t.code,{children:"CakeOrder"})," instead of ",(0,i.jsx)(t.code,{children:"IEnumerable<CakeOrder>"}),") GraphQL will enforce the type check and reject/fail the resolution for any parent item mapped to more than one child. This is useful for sibling relationships where two objects might be related but aren't otherwise aggregated together. For example, a person and their spouse."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"1 Source -> N Results"})}),"\n",(0,i.jsx)(t.p,{children:"If you've defined your extension to return a collection of items, like in the example, then GraphQL will generate an array of 0 or more children for every parent included in the batch."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"N Sources -> N Results"})}),"\n",(0,i.jsx)(t.p,{children:"To GraphQL, many to many relationships are treated the same as one to many. Internally, it doesn't care how you map your data, only that the type expression of the results are enforced. Each child can map to multiple parents and in the cases of overlap, GraphQL will resolve the requested fields of that child once then render it to each parent in the outgoing response package."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"1 Source -> No Results"})}),"\n",(0,i.jsxs)(t.p,{children:["For 1:1 results there are only two options; either the data exists and a value is returned or it doesn't and ",(0,i.jsx)(t.code,{children:"null"})," is returned. But with 1",":N"," relationships, sometimes you want to indicate that no results were ",(0,i.jsx)(t.em,{children:"included"})," for a parent item and sometimes you want to indicate that no results ",(0,i.jsx)(t.em,{children:"exist"}),". This could be represented as being an empty array vs. ",(0,i.jsx)(t.code,{children:"null"}),". When working with children, for every parent supplied to ",(0,i.jsx)(t.code,{children:"this.StartBatch"}),", GraphQL will generate a field result of ",(0,i.jsx)(t.strong,{children:"at least"})," an empty array. To indicate a parent item should receive ",(0,i.jsx)(t.code,{children:"null"})," instead of ",(0,i.jsx)(t.code,{children:"[]"})," exclude it from the batch."]}),"\n",(0,i.jsxs)(t.p,{children:["Note that it is your method's responsibility to be compliant with the type expression of the field. If a field is marked as ",(0,i.jsx)(t.code,{children:"NON_NULL"})," and you exclude the parent item from the batch (resulting in a null result for the field for that item) the field will be marked invalid and register an error."]}),"\n",(0,i.jsx)(t.admonition,{type:"caution",children:(0,i.jsxs)(t.p,{children:["Excluding a  source item from ",(0,i.jsx)(t.code,{children:"this.StartBatch()"})," will result in it receiving ",(0,i.jsx)(t.code,{children:"null"})," for its resolved field value. Be mindful of your extension's type expression. If you've made the field non-nullable an error will be generated."]})}),"\n",(0,i.jsxs)(t.h4,{id:"returning-idictionarytsource-tvalue",children:["Returning ",(0,i.jsx)(t.code,{children:"IDictionary<TSource, TValue>"})]}),"\n",(0,i.jsxs)(t.p,{children:["Using ",(0,i.jsx)(t.code,{children:"this.StartBatch"})," is the preferred way of returning data from a batch extension but there is a small amount of overhead to it. It has to join two separate lists of data on a common key, which could take a few extra cycles for large data sets."]}),"\n",(0,i.jsxs)(t.p,{children:["Another option would be to generate the same result yourself while you're generating your data set. Once its all said and done, ",(0,i.jsx)(t.code,{children:"this.StartBatch()"})," creates an ",(0,i.jsx)(t.code,{children:"IDictionary<TSource, TValue>"})," where ",(0,i.jsx)(t.code,{children:"TSource"})," is a parent object and ",(0,i.jsx)(t.code,{children:"TValue"})," is either a single child or an ",(0,i.jsx)(t.code,{children:"IEnumerable<Child>"})," depending on the type expression of your field. A batch extension is the only operation that will accept a return type of ",(0,i.jsx)(t.code,{children:"IDictionary"}),"."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["When returning ",(0,i.jsx)(t.code,{children:"IDictionary<TSource, TValue>"}),", the key ",(0,i.jsx)(t.strong,{children:"MUST BE"})," the original object reference supplied to the the extension method, not a copy."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["This is the example above  reconfigured to a custom dictionary. Note that when we use an ",(0,i.jsx)(t.code,{children:"IDictionary"})," return type, GraphQL is able to infer our field data type and an explicit declaration is no longer needed on the attribute."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="Using a Custom Dictionary"',children:'public class BakedGoodsCompanyController : GraphController\n{\n    [QueryRoot("bakeries")]\n    public async Task<List<Bakery>> RetrieveBakeries(Region region){/*...*/}\n\n    // declare the batch operation as an extension\n    // highlight-start\n    [BatchTypeExtension(typeof(Bakery), "orders")]\n    public async Task<IDictionary<Bakery, IEnumerable<CakeOrder>>> RetrieveCakeOrders(IEnumerable<Bakery> bakeries, int limitTo = 15)\n    // highlight-end\n    {\n        //fetch all the orders at once\n        Dictionary<Bakery, IEnumerable<CakeOrder>> allOrders = await _service\n                .RetrieveCakeOrders(bakeries, limitTo);\n\n        return allOrders;\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"other-resources",children:"Other Resources"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://itnext.io/what-is-the-n-1-problem-in-graphql-dd4921cb3c1a",children:"What is the N+1 Problem in GraphQL?"})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>o});var n=r(6540);const i={},a=n.createContext(i);function s(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);