"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[2477],{4562:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"controllers/authorization","title":"Authorization","description":"Quick Examples","source":"@site/docs/controllers/authorization.md","sourceDirName":"controllers","slug":"/controllers/authorization","permalink":"/docs/controllers/authorization","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"authorization","title":"Authorization","sidebar_label":"Authorization","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Field Paths","permalink":"/docs/controllers/field-paths"},"next":{"title":"Type Extensions","permalink":"/docs/controllers/type-extensions"}}');var i=n(4848),r=n(8453);const s={id:"authorization",title:"Authorization",sidebar_label:"Authorization",sidebar_position:3},a=void 0,l={},c=[{value:"Quick Examples",id:"quick-examples",level:2},{value:"Use of IAuthorizationService",id:"use-of-iauthorizationservice",level:2},{value:"When does Authorization Occur?",id:"when-does-authorization-occur",level:2},{value:"Field Authorizations",id:"field-authorizations",level:2},{value:"Field Authorization Failures are Obfuscated",id:"field-authorization-failures-are-obfuscated",level:3},{value:"Authorization on Execution Directives",id:"authorization-on-execution-directives",level:2},{value:"Authorization Methods",id:"authorization-methods",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2}];function u(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"quick-examples",children:"Quick Examples"}),"\n",(0,i.jsxs)(t.p,{children:["If you've wired up ASP.NET authorization before, you'll likely familiar with the ",(0,i.jsx)(t.code,{children:"[Authorize]"})," attribute and how its used to enforce security."]}),"\n",(0,i.jsx)(t.p,{children:"GraphQL ASP.NET works the same way."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="General Authorization Check"',children:'public class BakeryController : GraphController\n{\n    // highlight-next-line\n    [Authorize]\n    [MutationRoot("orderDonuts", typeof(CompletedDonutOrder))]\n    public async Task<IGraphActionResult> OrderDonuts(DonutOrderModel order)\n    {/*...*/}\n}\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="Restrict by Policy"',children:'public class BakeryController : GraphController\n{\n    // highlight-next-line\n    [Authorize(Policy = "CustomerLoyaltyProgram")]\n    [MutationRoot("orderDonuts", typeof(CompletedDonutOrder))]\n    public async Task<IGraphActionResult> OrderDonuts(DonutOrderModel order)\n    {/*...*/}\n}\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="Restrict by Role"',children:'public class BakeryController : GraphController\n{\n    // highlight-next-line\n    [Authorize(Roles = "Admin, Employee")]\n    [MutationRoot("purchaseDough")]\n    public async Task<bool> PurchaseDough(int kilosOfDough)\n    {/*...*/}\n}\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="Multiple Authorization Requirements"',children:'// The library supports nested policy and role checks at Controller and Action levels.\n// highlight-next-line\n[Authorize(Policy = "CurrentCustomer")]\npublic class BakeryController : GraphController\n{\n    // The user would have to pass the CurrentCustomer policy\n    // and the LoyaltyProgram policy to access the `orderDonuts` field\n\n    // highlight-next-line\n    [Authorize(Policy = "LoyaltyProgram")]\n    [MutationRoot("orderDonuts", typeof(CompletedDonutOrder))]\n    public async Task<IGraphActionResult> OrderDonuts(DonutOrderModel order)\n    {/*...*/}\n}\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="Use of [AllowAnonymous]"',children:'[Authorize]\npublic class BakeryController : GraphController\n{\n    [Authorize(Policy = "CustomerLoyaltyProgram")]\n    [MutationRoot("orderDonuts", typeof(CompletedDonutOrder))]\n    public async Task<IGraphActionResult> OrderDonuts(DonutOrderModel order)\n    {/*...*/}\n\n    // No Authorization checks on RetrieveDonutList\n    // highlight-next-line\n    [AllowAnonymous]\n    [Mutation("donutList")]\n    public async Task<IEnumerable<Donut>> RetrieveDonutList()\n    {/*...*/}\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"use-of-iauthorizationservice",children:"Use of IAuthorizationService"}),"\n",(0,i.jsxs)(t.p,{children:["Under the hood, GraphQL taps into your ",(0,i.jsx)(t.code,{children:"IServiceProvider"})," to obtain a reference to the ",(0,i.jsx)(t.code,{children:"IAuthorizationService"})," that gets created when you configure ",(0,i.jsx)(t.code,{children:".AddAuthorization()"})," at startup. Take a look at the ",(0,i.jsx)(t.a,{href:"https://github.com/graphql-aspnet/graphql-aspnet/tree/master/src/graphql-aspnet/Middleware/SchemaItemSecurity",children:"Schema Item Security Pipeline Components"})," for the full picture."]}),"\n",(0,i.jsx)(t.h2,{id:"when-does-authorization-occur",children:"When does Authorization Occur?"}),"\n",(0,i.jsxs)(t.p,{children:["GraphQL ASP.NET makes use of the result from ",(0,i.jsx)(t.a,{href:"https://docs.microsoft.com/en-us/aspnet/core/security/authorization/introduction",children:"ASP.NET's security pipeline"}),". Whether you use Kerberos tokens, oauth2, username/password, API tokens or if you support 2-factor authentication or one-time-use passwords, GraphQL doesn't care. The entirety of your authentication and authorization scheme is executed by GraphQL, no special arrangements or configuration is needed."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"GraphQL ASP.NET draws from your configured authentication/authorization solution."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Execution directives and field resolutions are passed through the libraries internal ",(0,i.jsx)(t.a,{href:"../reference/how-it-works#middleware-pipelines",children:"pipeline"})," where securty is enforced as a series of middleware components before the respective resolvers are invoked. Should a requestor not be authorized for a given schema item they are informed via an error message and denied access to the item."]}),"\n",(0,i.jsx)(t.h2,{id:"field-authorizations",children:"Field Authorizations"}),"\n",(0,i.jsxs)(t.p,{children:["If a requestor is not authorized to a requested field a value of ",(0,i.jsx)(t.code,{children:"null"})," is used as the resolved value and an error message is recorded to the query results."]}),"\n",(0,i.jsx)(t.p,{children:'Null propagation rules still apply to unauthorized fields meaning if the field cannot accept a null value, its propagated up the field chain potentially nulling out a parent or "parent of a parent" depending on your schema.'}),"\n",(0,i.jsx)(t.p,{children:"By default, a single unauthorized field result does not necessarily kill an entire query, it depends on the structure of your object graph and the query being executed. When a field request is terminated any down-stream child fields are discarded immediately but sibling fields or unrelated ancestors continue to execute as normal."}),"\n",(0,i.jsx)(t.p,{children:'Since this authorization occurs "per field" and not "per controller action" its possible to define the same security chain for POCO properties. This allows you to effectively deny access, by policy, to a single property of an instantiated object. Performing security checks for every field of data (especially in parent/child scenarios) has a performance cost though, especially for larger data sets. For most scenarios enforcing security at the controller level is sufficient.'}),"\n",(0,i.jsx)(t.h3,{id:"field-authorization-failures-are-obfuscated",children:"Field Authorization Failures are Obfuscated"}),"\n",(0,i.jsxs)(t.p,{children:["When GraphQL denies a requestor access to a field a message naming the field path is added to the response. This message is generic on purpose. Suppose there was a query where the user requests the ",(0,i.jsx)(t.code,{children:"allDonuts"})," field but is denied access:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-graphql",children:"    {\n        donut(id: 5) {\n            name\n        }\n        allDonuts {\n            name\n        }\n\n    }\n\n"})}),"\n",(0,i.jsx)(t.p,{children:"The result might look like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-json",metastring:'title="Denied Field Access"',children:'{\n  "errors": [\n    // highlight-start\n    {    \n      "message": "Access Denied to field [query]/allDonuts",\n      "locations": [\n        {\n          "line": 7,\n          "column": 3\n        }\n      ],\n      "path": [\n        "allDonuts"\n      ],\n      "extensions": {\n        "code": "ACCESS_DENIED",\n        "timestamp": "2022-12-22T22:22:25.017-07:00",\n        "severity": "CRITICAL"\n      }\n    }\n    // highlight-end\n  ],\n  "data": {\n    "donut": {\n      "name": "Super Mega Donut",\n    },\n    // highlight-next-line\n    "allDonuts": null\n  }\n}\n'})}),"\n",(0,i.jsxs)(t.admonition,{type:"tip",children:[(0,i.jsxs)(t.p,{children:["To view more details authorization failure reasons, such as specific policy failures, you'll need to expose exceptions on the request or turn on ",(0,i.jsx)(t.a,{href:"../logging/structured-logging",children:"logging"}),"."]}),(0,i.jsxs)(t.p,{children:["GraphQL automatically raises the ",(0,i.jsx)(t.code,{children:"SchemaItemAuthorizationCompleted"})," log event at a ",(0,i.jsx)(t.code,{children:"Warning"})," level when a security check fails."]})]}),"\n",(0,i.jsx)(t.h2,{id:"authorization-on-execution-directives",children:"Authorization on Execution Directives"}),"\n",(0,i.jsxs)(t.p,{children:["Execution directives are applied to the ",(0,i.jsx)(t.em,{children:"query document"}),", before a query plan is created to fulfill the request. However, it is the query plan that determines which field resolvers should be called. As a result, execution directives have the potential to alter the document structure and change how a query plan might be structured. Because of this, not executing a query directive has the potential to cause a the expected query to be different than what the requestor intended."]}),"\n",(0,i.jsx)(t.p,{children:"Therefore, if an execution directive fails authorization the query is rejected and not executed.  The caller will receive an error message as part of the response indicating the unauthorized directive. Like field authorization failures, the message is obfuscated and contains only a generic message. You'll need to expose exception on the request or turn on logging to see additional details."}),"\n",(0,i.jsx)(t.h2,{id:"authorization-methods",children:"Authorization Methods"}),"\n",(0,i.jsx)(t.p,{children:"GraphQL ASP.NET supports two methods of applying the authorization rules out of the box."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"PerField"}),": Each field is authorized individually. If a query references some fields the user can access and some they cannot, those fields the user can access are resolved as expected. A ",(0,i.jsx)(t.code,{children:"null"})," value is assigned to the fields the user cannot access."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"PerRequest"}),": All fields that require authorization are authorized at once. If the user is unauthorized on 1 or more fields the entire request is denied and not executed."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Configure the authorization method at startup:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="Startup"',children:"services.AddGraphQL(schemaOptions =>\n{\n    schemaOptions.AuthorizationOptions.Method = AuthorizationMethod.PerRequest;\n});\n"})}),"\n",(0,i.jsx)(t.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsxs)(t.p,{children:["Authorization is not free. There is a minor, but real, performance cost to inspecting and evaluating policies on each field. This true regardless of yor choice of ",(0,i.jsx)(t.code,{children:"PerField"})," or ",(0,i.jsx)(t.code,{children:"PerRequest"})," authorization. Every secured field still needs to be evaluated, whether it is done up front or as the query progresses.  In a REST query, you generally only secure your top-level controller methods, consider doing the same with your GraphQL queries."]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["Centralize your authorization checks to your controller methods. There is usually no need to apply ",(0,i.jsx)(t.code,{children:"[Authorize]"}),"  attributes to each and every method and property across your entire schema."]})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var o=n(6540);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);