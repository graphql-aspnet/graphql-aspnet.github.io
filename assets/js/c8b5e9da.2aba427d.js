"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[4206],{2094:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"types/list-non-null","title":"List & Non-Null","description":"In addition to the six fundamental graph types, GraphQL contains two meta graph types: LIST and NON_NULL.","source":"@site/docs/types/list-non-null.md","sourceDirName":"types","slug":"/types/list-non-null","permalink":"/docs/types/list-non-null","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"list-non-null","title":"List & Non-Null","sidebar_label":"List & Non-Null","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Scalars","permalink":"/docs/types/scalars"},"next":{"title":"Subscriptions","permalink":"/docs/advanced/subscriptions"}}');var r=s(4848),i=s(8453);const l={id:"list-non-null",title:"List & Non-Null",sidebar_label:"List & Non-Null",sidebar_position:6},o=void 0,a={},d=[{value:"Type Expressions",id:"type-expressions",level:2},{value:"Overriding Type Expressions",id:"overriding-type-expressions",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In addition to the six fundamental graph types, GraphQL contains two meta graph types: ",(0,r.jsx)(n.a,{href:"https://graphql.org/learn/schema/#lists-and-non-null",children:"LIST and NON_NULL"}),"."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"NON_NULL"})," : Indicates that the Graph Type its describing must not be a null value, be that as an input argument or returned from a field"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"LIST"}),": Indicates that GraphQL should expect a collection of objects instead of just a single item."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:['These meta types aren\'t anything concrete like a scalar or an enum. Instead they "wrap" another graph type (such as ',(0,r.jsx)(n.code,{children:"int"})," or ",(0,r.jsx)(n.code,{children:"Donut"}),"). They are used to describe the usage of a graph type in a field or input argument:"]}),"\n",(0,r.jsx)(n.p,{children:"For example, we would say:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:['"A field that returns a ',(0,r.jsx)(n.code,{children:"Float"}),' number."']}),"\n",(0,r.jsxs)(n.li,{children:['"A field that must return a ',(0,r.jsx)(n.code,{children:"Person"}),'."']}),"\n",(0,r.jsxs)(n.li,{children:['"An input argument that must be a ',(0,r.jsx)(n.code,{children:"Date"}),'."']}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We can even describe complex scenarios:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:['"A field that ',(0,r.jsx)(n.strong,{children:"might"})," return a collection of ",(0,r.jsx)(n.code,{children:"persons"})," but when returned, each person ",(0,r.jsx)(n.strong,{children:"must"}),' be a valid reference."']}),"\n",(0,r.jsxs)(n.li,{children:['"An input argument that ',(0,r.jsx)(n.strong,{children:"must"})," be a list that contains lists of ",(0,r.jsx)(n.code,{children:"integers"}),'." (e.g. ',(0,r.jsx)(n.code,{children:"[[1, 2], [5, 15]]"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"type-expressions",children:"Type Expressions"}),"\n",(0,r.jsxs)(n.p,{children:['Together these "wrappers" make up a field\'s ',(0,r.jsx)(n.code,{children:"Type Expression"}),". GraphQL ASP.NET will automatically infer a type expression for every field and every input argument when generating your schema."]}),"\n",(0,r.jsx)(n.p,{children:"The following assumptions about your data are made when creating type expressions:"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705  Reference types ",(0,r.jsx)(n.strong,{children:"can be"})," null ",(0,r.jsx)("br",{}),"\n\u2705  Value types ",(0,r.jsx)(n.strong,{children:"cannot be"})," null ",(0,r.jsx)("br",{}),"\n\u2705  Nullable value types (e.g. ",(0,r.jsx)(n.code,{children:"int?"}),") ",(0,r.jsx)(n.strong,{children:"can be"})," null ",(0,r.jsx)("br",{}),"\n\u2705  When a reference type implements ",(0,r.jsx)(n.code,{children:"IEnumerable<TType>"}),' it will be expressed as a "list of ',(0,r.jsx)(n.code,{children:"TType"}),'"']}),"\n",(0,r.jsx)(n.p,{children:"Type Expressions are commonly shown in the GraphQL schema syntax for field definitions. Here are a few examples of a .NET type and its equivalent type expression in schema syntax."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:".NET Type"}),(0,r.jsx)(n.th,{children:"Type Expression"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"int"}),(0,r.jsx)(n.td,{children:"Int!"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"float?"}),(0,r.jsx)(n.td,{children:"Float"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IEnumerable<Person>"}),(0,r.jsx)(n.td,{children:"[Person]"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Person[]"}),(0,r.jsx)(n.td,{children:"[Person]"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"List<bool>"}),(0,r.jsx)(n.td,{children:"[Boolean!]"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IReadOnlyList<long>"}),(0,r.jsx)(n.td,{children:"[Long!]"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IReadOnlyList<long?>"}),(0,r.jsx)(n.td,{children:"[Long]"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IEnumerable<List<ICollection<Donut>>>"}),(0,r.jsx)(n.td,{children:"[[[Donut]]]"})]})]})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"!"})," indicates NON_NULL and ",(0,r.jsx)(n.code,{children:"[]"})," for a LIST."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"overriding-type-expressions",children:"Overriding Type Expressions"}),"\n",(0,r.jsxs)(n.p,{children:["You may need to override the default behavior from time to time. For instance, a ",(0,r.jsx)(n.code,{children:"string"}),", which is a reference type, is nullable by default but you may want to enforce non-nullability at the query level and declare that null is not valid for a given argument. Or, perhaps, an object implements ",(0,r.jsx)(n.code,{children:"IEnumerable"})," but you don't want graphql to treat it as a list."]}),"\n",(0,r.jsxs)(n.p,{children:["You can override the default type expression of any field or argument by defining a ",(0,r.jsx)(n.a,{href:"../advanced/type-expressions",children:"custom type expression"})," when needed."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var t=s(6540);const r={},i=t.createContext(r);function l(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);