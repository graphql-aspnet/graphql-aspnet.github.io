"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[8956],{7544:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"types/interfaces","title":"Interfaces","description":"Interfaces in GraphQL work like interfaces in C#, for the most part. They provide a contract for a set of common fields amongst different objects. When it comes to declaring them, the INTERFACE graph type works exactly like object types.","source":"@site/docs/types/interfaces.md","sourceDirName":"types","slug":"/types/interfaces","permalink":"/docs/types/interfaces","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"interfaces","title":"Interfaces","sidebar_label":"Interfaces","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Input Objects","permalink":"/docs/types/input-objects"},"next":{"title":"Unions","permalink":"/docs/types/unions"}}');var a=t(4848),r=t(8453);const s={id:"interfaces",title:"Interfaces",sidebar_label:"Interfaces",sidebar_position:2},l=void 0,c={},o=[{value:"Inheritance and Implmentations",id:"inheritance-and-implmentations",level:2},{value:"Use it to Include it",id:"use-it-to-include-it",level:3},{value:"Implmenting Other Interfaces",id:"implmenting-other-interfaces",level:3},{value:"Interfaces are not Input Objects",id:"interfaces-are-not-input-objects",level:2},{value:"Interface Names",id:"interface-names",level:2},{value:"Methods as Fields",id:"methods-as-fields",level:2},{value:"Excluding Fields",id:"excluding-fields",level:2},{value:"Forced Interface Exclusions",id:"forced-interface-exclusions",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Interfaces in GraphQL work like interfaces in C#, for the most part. They provide a contract for a set of common fields amongst different objects. When it comes to declaring them, the ",(0,a.jsx)(n.code,{children:"INTERFACE"})," graph type works exactly like ",(0,a.jsx)(n.a,{href:"./objects",children:"object types"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"By default, when creating an interface graph type, the library:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Will name the interface the same as its C# type name."}),"\n",(0,a.jsx)(n.li,{children:"Will include all properties that have a getter."}),"\n",(0,a.jsx)(n.li,{children:"Will ignore any methods."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="IPastry.cs"',children:"public interface IPastry\n{\n    int Id { get; set; }\n    string Name { get; set; }\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",metastring:'title="IPastry Type Definition"',children:"interface IPastry {\n  id: Int!\n  name: String\n}\n"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["You can override the default settings in your ",(0,a.jsx)(n.a,{href:"/docs/reference/schema-configuration#fielddeclarationrequirements",children:"schema configuration"})," or by use of the ",(0,a.jsx)(n.a,{href:"/docs/reference/attributes#graphtype",children:"GraphType"})," and ",(0,a.jsx)(n.a,{href:"/docs/reference/attributes#graphfield",children:"GraphField"})," attributes."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"inheritance-and-implmentations",children:"Inheritance and Implmentations"}),"\n",(0,a.jsxs)(n.p,{children:["The section on working with interfaces with ",(0,a.jsx)(n.a,{href:"../controllers/actions#working-with-interfaces",children:"action methods"})," provides a great discussion on proper usage but its worth pointing out here as well."]}),"\n",(0,a.jsxs)(n.p,{children:["You must let GraphQL know of the possible object types which implement your interface. If your action method returns ",(0,a.jsx)(n.code,{children:"IPastry"})," and you return a ",(0,a.jsx)(n.code,{children:"Donut"}),", but didn't let GraphQL know about the ",(0,a.jsx)(n.code,{children:"Donut"})," class, it won't be able to continue to resolve the requested fields as it won't know which resolvers to call. This is especially true if you use type restricted fragments or spreads."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="BakeryController.cs"',children:"public class BakeryController : GraphController\n{\n    // highlight-next-line\n    [QueryRoot(typeof(Donut), typeof(Cake))]\n    public IPastry SearchPastries(string name)\n    {/* ... */}\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",metastring:'title="Sample Query"',children:'query {\n    searchPastries(name: "chocolate*") {\n        id\n        name\n\n        ...on Donut {\n            isFilled\n        }\n\n        ...on Cake {\n            icingFlavor\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"use-it-to-include-it",children:"Use it to Include it"}),"\n",(0,a.jsx)(n.p,{children:"Unless an interface is actually referenced as a return value of a field, be it from an action method or a model property, it won't be added to your schema and won't be visible to introspection queries."}),"\n",(0,a.jsxs)(n.p,{children:["That is to say that when you register ",(0,a.jsx)(n.code,{children:"Donut"}),", unless you specifically return ",(0,a.jsx)(n.code,{children:"IPastry"})," from your application, GraphQL will leave it out of the schema. This goes a long ways in preventing security vulnerabilities and reducing clutter in your schema with all the interfaces you may declare internally. For instance, while common in .NET, its doubtful that you ever want to expose ",(0,a.jsx)(n.code,{children:"IEnumerable"})," to your graph."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="IPastry is never used"',children:"public class BakeryController : GraphController\n{\n    [QueryRoot]\n    public Donut FindDonut(string name)\n    {/* ... */}\n}\n\npublic class Donut : IPastry\n{/*...*/}\n\n// IPastry will be excluded from the schema since\n// its not referenced in any controllers or other object properties.\npublic interface IPastry\n{/*...*/}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",metastring:'title="Type Definitions"',children:"# Donut is published on the schema\n# but IPastry is not included\ntype Donut {\n  id: Int!\n  name: String\n  ...\n}\n"})}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsx)(n.mdxAdmonitionTitle,{}),(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"schemaOptions.AddGraphType<IPastry>()"})," during ",(0,a.jsx)(n.a,{href:"../reference/schema-configuration",children:"schema configuration"})," at startup to force GraphQL to publish the interface, even if its never used in the graph. This is true for any graph type."]})]}),"\n",(0,a.jsx)(n.h3,{id:"implmenting-other-interfaces",children:"Implmenting Other Interfaces"}),"\n",(0,a.jsx)(n.p,{children:"Interfaces implementing other interfaces worksa bit differently than it does in .NET.  Take for example, these two interfaces:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="C# Interface Inheritance"',children:"public interface IPastry\n{\n    int Id { get; set; }\n    string Name { get; set; }\n}\n\npublic interface IDonut : IPastry\n{\n    string Flavor{ get; set; }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In .NET ",(0,a.jsx)(n.code,{children:"IDonut"}),", by virtue of implementing ",(0,a.jsx)(n.code,{children:"IPastry"}),', grants "access" to the ',(0,a.jsx)(n.code,{children:"Id"})," and ",(0,a.jsx)(n.code,{children:"Name"})," fields for any object that implements IDonut since said object must implement both interfaces to compile correctly. However, this is not the case with interfaces in your graphql schema. As said above, since interfaces are not automatically parsed the fields they define are also not automatically included in child interfaces."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="Startup Code"',children:"services.AddGraphQL(o => \n{\n  // only include IDonut in the schema\n  // highlight-next-line\n   o.AddGraphType<IDonut>();\n});\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",metastring:'title="IDonut Type Definition"',children:"# IDonut DOES NOT contain name or id\n# because IPastry is not part of the schema\ninterface IDonut {\n  flavor: String\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"However, GraphQL does support interface inheritance. As long as both interfaces are included as part of the schema then the fields will wire up as you'd expect."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="Startup Code"',children:"services.AddGraphQL(o => \n{\n  // Include both interfaces\n  // highlight-start\n  o.AddGraphType<IPastry>();  \n  o.AddGraphType<IDonut>();\n  // highlight-end\n});\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",metastring:'title="Type Definitions"',children:"interface IPastry {  \n  id: Int!\n  name: String\n}\n\n# IDonut DOES contain all the expected fields\n# Since IPastry is included\n// highlight-next-line\ninterface IDonut implements IPastry {  \n  id: Int!\n  name: String\n  flavor: String\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"GraphQL will NOT attempt to include inherited fields unless the interface they are declared on is part the schema."})}),"\n",(0,a.jsx)(n.h2,{id:"interfaces-are-not-input-objects",children:"Interfaces are not Input Objects"}),"\n",(0,a.jsxs)(n.p,{children:['The GraphQL specification states that "interfaces are never valid inputs" [',(0,a.jsx)(n.a,{href:"https://graphql.github.io/graphql-spec/October2021/#sec-Interfaces",children:"Spec \xa7 3.7"}),"]. The runtime will reject any attempts to use an interface as a parameter to a method (i.e. a field argument) that is exposed on the graph."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="Interfaces cannot be used as input arguments"',children:"public class BakeryController : GraphController\n{\n    // ERROR!\n    // A GraphTypeDeclarationException will be thrown\n    [Mutation]\n    // highlight-next-line\n    public Donut AddNewDonut(IPastry newPastry)\n    {/* ... */}\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"interface-names",children:"Interface Names"}),"\n",(0,a.jsxs)(n.p,{children:["Like with other graph types use the ",(0,a.jsx)(n.code,{children:"[GraphType]"})," attribute to indicate a custom name for the interface in the object graph."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="Interface Custom Name"',children:'// highlight-next-line\n[GraphType("Pastry")]\npublic interface IPastry\n{\n    int Id { get; set; }\n    string Name { get; set; }\n}\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",metastring:'title="Graph Type Definition"',children:"interface Pastry {\n  id: Int!\n  name: String\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"methods-as-fields",children:"Methods as Fields"}),"\n",(0,a.jsxs)(n.p,{children:["By default, interface methods are excluded from being fields on the graph but can be added by tagging the method with ",(0,a.jsx)(n.code,{children:"[GraphField]"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="Including a POCO method as a field"',children:'public interface IPastry\n{\n    // highlight-next-line\n    [GraphField("salesTax")]\n    decimal CalculateSalesTax(decimal taxPercentage);\n\n    int Id { get; set; }\n    string Name { get; set; }\n    decimal Price { get; set; }\n}\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",metastring:'title="IPastry Type Definition"',children:"inteface IPastry {\n  // highlight-next-line\n  salesTax (taxPercentage: Decimal!): Decimal!\n  id: Int!\n  name: String\n  price: Decimal!\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Just as with ",(0,a.jsx)(n.a,{href:"../controllers/actions",children:"controller actions"}),", GraphQL will analyze the signature of the method to determine its return type, expression requirements and input arguments."]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["Methods on interfaces lack many of the features of controllers such as being able to perform ",(0,a.jsx)(n.a,{href:"../controllers/model-state",children:"model state"})," validation or provide access to ",(0,a.jsx)(n.code,{children:"this.User"})," and ",(0,a.jsx)(n.code,{children:"this.Request"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"excluding-fields",children:"Excluding Fields"}),"\n",(0,a.jsxs)(n.p,{children:["To exclude a single property that you don't want to expose to GraphQL add the ",(0,a.jsx)(n.code,{children:"[GraphSkip]"})," attribute to it:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="Excluding a property"',children:"public interface IPastry\n{\n    int Id { get; set; }\n    string Name { get; set; }\n\n    // highlight-next-line\n    [GraphSkip]\n    decimal Price { get; set; }\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",metastring:'title="IPastry Type Definition"',children:"interface IPastry {\n  id: Int!\n  name: String\n  # price is not included\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or force GraphQL to skip all fields except those you explicitly define with a ",(0,a.jsx)(n.code,{children:"[GraphField]"})," attribute:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="Require explicit declarations for this type"',children:"// highlight-next-line\n[GraphType(FieldDeclarationRequirements = TemplateDeclarationRequirements.RequireAll)]\npublic interface IPastry\n{\n    [GraphField]\n    int Id { get; set; }\n\n    [GraphField]\n    string Name { get; set; }\n\n    decimal Price { get; set; }\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",metastring:'title="IPastry Type Definition"',children:"# only id and name are included\ninterface IPastry {\n  id: Int!\n  name: String\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Or set a schema-wide option during startup:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="Set Field Declaration Requirements at Startup"',children:"services.AddGraphQL(options =>\n  {\n      options.DeclarationOptions.FieldDeclarationRequirements = TemplateDeclarationRequirements.RequireAll;\n  });\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Your schema will follow a cascading model of inclusion rules in order of increasing priority from ",(0,a.jsx)(n.code,{children:"schema -> class -> field"})," level declarations. This can be useful in multi-schema setups where a class may be shared but you don't want the exposed fields to be different or if there is a secure field that you want to guarantee is not exposed regardless of the schema."]}),"\n",(0,a.jsx)(n.h2,{id:"forced-interface-exclusions",children:"Forced Interface Exclusions"}),"\n",(0,a.jsx)(n.p,{children:"Perhaps there exists an interface in a shared assembly used amongst multiple work teams that contains some utility classes that absolutely, positively CANNOT be exposed to GraphQL at any cost."}),"\n",(0,a.jsxs)(n.p,{children:["In these cases, add ",(0,a.jsx)(n.code,{children:"[GraphSkip]"})," to an interface and GraphQL will throw a ",(0,a.jsx)(n.code,{children:"GraphTypeDeclarationException"})," if its ever asked to include it in a schema."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:'title="Prevent a Type from EVER Being Included in the Graph"',children:"// ERROR, GraphTypeDeclarationException will be thrown!\n[GraphSkip]\npublic interface IPastry\n{\n    int Id { get; set; }\n    string Name { get; set; }\n    decimal Price { get; set; }\n}\n"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["This rule is enforced at the template level and is applied to the ",(0,a.jsx)(n.code,{children:"System.Type"}),". Its not specific to the ",(0,a.jsx)(n.code,{children:"INTERFACE"})," graph type. Any class, interface, enum etc. with the ",(0,a.jsx)(n.code,{children:"[GraphSkip]"})," attribute will be permanantly skipped."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);