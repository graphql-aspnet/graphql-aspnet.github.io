"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[7219],{1833:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"execution/malicious-queries","title":"Dealing with Malicious Queries","description":"When GraphQL ASP.NET parses a query it creates two values that attempt to describe the query in terms of impact and server load; Max Depth and Estimated Complexity. There also exists limiters to these values that can be set in the schema configuration such that should any query plan exceed the limits you set, the plan will be rejected and the query not fulfilled.","source":"@site/docs/execution/malicious-queries.md","sourceDirName":"execution","slug":"/execution/malicious-queries","permalink":"/docs/execution/malicious-queries","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"malicious-queries","title":"Dealing with Malicious Queries","sidebar_label":"Malicious Queries","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Query Profiling","permalink":"/docs/execution/metrics"},"next":{"title":"Debugging","permalink":"/docs/development/debugging"}}');var r=i(4848),a=i(8453);const l={id:"malicious-queries",title:"Dealing with Malicious Queries",sidebar_label:"Malicious Queries",sidebar_position:1},o=void 0,s={},c=[{value:"Maximum Allowed Field Depth",id:"maximum-allowed-field-depth",level:2},{value:"Query Complexity",id:"query-complexity",level:2},{value:"Calculating Query Complexity",id:"calculating-query-complexity",level:3},{value:"Setting a Complexity Weight",id:"setting-a-complexity-weight",level:3},{value:"Implement Your Own Complexity Calculation",id:"implement-your-own-complexity-calculation",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"When GraphQL ASP.NET parses a query it creates two values that attempt to describe the query in terms of impact and server load; Max Depth and Estimated Complexity. There also exists limiters to these values that can be set in the schema configuration such that should any query plan exceed the limits you set, the plan will be rejected and the query not fulfilled."}),"\n",(0,r.jsx)(t.h2,{id:"maximum-allowed-field-depth",children:"Maximum Allowed Field Depth"}),"\n",(0,r.jsx)(t.p,{children:"Field depth refers to how deeply nested a field is within a query."}),"\n",(0,r.jsxs)(t.p,{children:['In this example, for instance, the "search" field has a depth of 4 and the maximum depth reached is 6: ',(0,r.jsx)(t.code,{children:"groceryStore > bakery > pastries > recipe > ingredients > name"})]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-graphql",metastring:'title="Sample Query"',children:'query SearchGroceryStore {\n    groceryStore {\n        bakery {\n            pastries {\n                search(nameLike: "chocolate"){\n                    name\n                    type\n                }\n                recipe(id: 15) {\n                    name\n                    ingredients {\n                        name\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"This becomes important on large object graphs where its possible for a requestor to submit a query that is 10s or 100s of nodes deep. Running such a large query can have performance implications if ran en masse. Think of large, deeply nested queries run as part of a DDos attack."}),"\n",(0,r.jsx)(t.p,{children:"To combat this you can set a maximum allowed depth for any query targeting your schema. During the parsing phase, once GraphQL has gathered enough information about the query document and target operation, it will inspect the maximum depth and if it violates your constraint, immediately reject the query without executing it."}),"\n",(0,r.jsx)(t.p,{children:"To set a maximum allowed depth, set the appropriate property in your schema configuration at startup:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'title="Configure Max Query Depth"',children:"services.AddGraphQL(options =>\n{\n    options.ExecutionOptions.MaxQueryDepth = 15;\n});\n"})}),"\n",(0,r.jsx)(t.admonition,{title:"Default Max Query Depth",type:"info",children:(0,r.jsxs)(t.p,{children:["The default value for ",(0,r.jsx)(t.code,{children:"MaxQueryDepth"})," is ",(0,r.jsx)(t.code,{children:"null"})," (i.e. no limit)."]})}),"\n",(0,r.jsx)(t.h2,{id:"query-complexity",children:"Query Complexity"}),"\n",(0,r.jsx)(t.p,{children:"The field depth is only part of the picture though. The way in which your fields interact with each other also plays a role."}),"\n",(0,r.jsx)(t.p,{children:"Take for instance this query:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-graphql",metastring:'title="Sample Query"',children:"query PhoneManufacturer {\n    allParts {\n        id\n        name\n        suppliers {\n            name\n            address\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"It would not be far fetched to assume that this phone manufacturer has at least 500 parts in their inventory and that those parts might be sourced from 2-3 individual suppliers. If that's the case our result is going to contain 3000 field resolutions (500 parts * 3 suppliers * 2 fields per supplier) just to show the name and address of each supplier. Thats a lot of data!!!! What if we added order history per supplier? Now we'd looking at 100,000+ results. The take away here is that your field resolutions can balloon quickly, even on small queries, if you're not careful."}),"\n",(0,r.jsxs)(t.p,{children:["While this query only has a field depth of 3, ",(0,r.jsx)(t.code,{children:"allParts > suppliers > name"}),", the performance implications are much more impactful than the bakery in the first example because of the type of data involved. (Side note: this is a perfect example where a ",(0,r.jsx)(t.a,{href:"../controllers/batch-operations",children:"batch operation"})," would improve performance exponentially.)"]}),"\n",(0,r.jsxs)(t.p,{children:["GraphQL will assign an ",(0,r.jsx)(t.code,{children:"estimated complexity"})," score to each query plan to help gauge the load its likely to incur on the server when trying to execute. As you might expect you can set a maximum allowed complexity value and reject any queries that exceed your limit:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'title="Configure Max Allowed Query Complexity"',children:"services.AddGraphQL(options =>\n{\n    options.ExecutionOptions.MaxQueryComplexity = 50.00;\n});\n"})}),"\n",(0,r.jsx)(t.admonition,{title:"Default Max Complexity",type:"info",children:(0,r.jsxs)(t.p,{children:["The default value for ",(0,r.jsx)(t.code,{children:"MaxQueryComplexity"})," is ",(0,r.jsx)(t.code,{children:"null"})," (i.e. no maximum)."]})}),"\n",(0,r.jsx)(t.h3,{id:"calculating-query-complexity",children:"Calculating Query Complexity"}),"\n",(0,r.jsx)(t.p,{children:"After a query plan is generated, the chosen operation is inspected and weights are applied to each of the fields then summed together to generate a final score."}),"\n",(0,r.jsx)(t.p,{children:"A complexity score is derived from these attributes:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Attribute"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Operation Type"}),(0,r.jsxs)(t.td,{children:["This refers to the operation being a ",(0,r.jsx)(t.code,{children:"mutation"})," or a ",(0,r.jsx)(t.code,{children:"query"}),". Mutations are weighted more than queries."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Execution Mode"}),(0,r.jsx)(t.td,{children:'Whether or not a given field is being executed as a batch operation or "per source item".'})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Resolver Type"}),(0,r.jsx)(t.td,{children:"The type of resolver being invoked.  For example, controller actions are weighted more heavily than simple property resolvers."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Type Expression"}),(0,r.jsx)(t.td,{children:"Does the field produce 1 single item or a collection of items?"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Complexity Factor"}),(0,r.jsx)(t.td,{children:"A user controlled value to influence the calculation for queries or mutations that are particularly long running"})]})]})]}),"\n",(0,r.jsxs)(t.p,{children:["The code for calculating the value can be seen in ",(0,r.jsx)(t.a,{href:"https://github.com/graphql-aspnet/graphql-aspnet/blob/master/src/graphql-aspnet/Engine/DefaultOperationComplexityCalculator%7BTSchema%7D.cs",children:(0,r.jsx)(t.code,{children:"DefaultOperationComplexityCalculator<TSchema>"})})]}),"\n",(0,r.jsx)(t.h3,{id:"setting-a-complexity-weight",children:"Setting a Complexity Weight"}),"\n",(0,r.jsx)(t.p,{children:"You can influence the complexity value of any given field by applying a weight to the field as part of its declaration."}),"\n",(0,r.jsxs)(t.p,{children:["The attributes ",(0,r.jsx)(t.code,{children:"[GraphField]"}),", ",(0,r.jsx)(t.code,{children:"[Query]"}),", ",(0,r.jsx)(t.code,{children:"[Mutation]"}),", ",(0,r.jsx)(t.code,{children:"[QueryRoot]"}),", ",(0,r.jsx)(t.code,{children:"[MutationRoot]"})," expose access to this value."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'title="BakeryController.cs"',children:"public class BakeryController : GraphController\n{\n    // Complexity is a float value\n    // highlight-next-line\n    [QueryRoot(Complexity = 1.3)]\n    public Donut RetrieveDonutType(int id){/*...*/}\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"A factor greater than 1 will increase the weight applied to this field"}),"\n",(0,r.jsx)(t.li,{children:"A factor less than 1 will decrease the weight"}),"\n",(0,r.jsxs)(t.li,{children:["The minimum value is ",(0,r.jsx)(t.code,{children:"0"})," and the default value is ",(0,r.jsx)(t.code,{children:"1"})]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Complexity scores that do not exceed the limit are written to ",(0,r.jsx)(t.code,{children:"QueryPlanGenerated (EventId: 86400)"}),", a debug level event, after the query plan is successfully generated. Complexity scores that do exceed the limit are written directly to the errors collection on the query response."]}),"\n",(0,r.jsx)(t.admonition,{title:"Profile Your Queries",type:"tip",children:(0,r.jsx)(t.p,{children:"There is no magic bullet for choosing complexity values or setting a maximum allowed value as its going to be largely dependent on your data and how customers query it. Spend time profiling your queries, investigate their calculated complexities and act accordingly."})}),"\n",(0,r.jsx)(t.h2,{id:"implement-your-own-complexity-calculation",children:"Implement Your Own Complexity Calculation"}),"\n",(0,r.jsxs)(t.p,{children:["You can override how the library calculates the complexity of any given query operation. Implement ",(0,r.jsx)(t.code,{children:"IQueryOperationComplexityCalculator<TSchema>"})," and inject it into your DI container before calling ",(0,r.jsx)(t.code,{children:".AddGraphQL()"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["This interface has one method where ",(0,r.jsx)(t.code,{children:"IGraphFieldExecutableOperation"})," represents the collection of requested fields contexts along with the input arguments, child fields and directives that are about to be executed:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'title="IQueryOperationComplexityCalculator<TSchema>.cs"',children:"public interface IQueryOperationComplexityCalculator<TSchema>\n{\n    float Calculate(IGraphFieldExecutableOperation operation);\n}\n"})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>l,x:()=>o});var n=i(6540);const r={},a=n.createContext(r);function l(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);