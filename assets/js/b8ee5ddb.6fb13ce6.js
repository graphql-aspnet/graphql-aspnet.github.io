"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[2286],{8453:(e,r,t)=>{t.d(r,{R:()=>s,x:()=>i});var a=t(6540);const n={},o=a.createContext(n);function s(e){const r=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),a.createElement(o.Provider,{value:r},e.children)}},8956:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"reference/vocabulary","title":"Vocabulary","description":"Fields & Resolvers","source":"@site/docs/reference/vocabulary.md","sourceDirName":"reference","slug":"/reference/vocabulary","permalink":"/docs/reference/vocabulary","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"id":"vocabulary","title":"Vocabulary","sidebar_label":"Vocabulary","sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Benchmarks","permalink":"/docs/reference/performance"}}');var n=t(4848),o=t(8453);const s={id:"vocabulary",title:"Vocabulary",sidebar_label:"Vocabulary",sidebar_position:11},i=void 0,l={},c=[{value:"Fields &amp; Resolvers",id:"fields--resolvers",level:3},{value:"Graph Type",id:"graph-type",level:3},{value:"Query Document",id:"query-document",level:3},{value:"Root Graph Types",id:"root-graph-types",level:3},{value:"Schema",id:"schema",level:3}];function u(e){const r={admonition:"admonition",blockquote:"blockquote",code:"code",h3:"h3",p:"p",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h3,{id:"fields--resolvers",children:"Fields & Resolvers"}),"\n",(0,n.jsx)(r.p,{children:"In GraphQL terms, a field is any requested piece of data (such as an id or  name).  A resolver fulfills the request for data from a schema field. It takes in a set of input arguments and produces a piece of data that is returned to the client. In GraphQL ASP.NET your controller methods act as resolvers for top level fields in any query."}),"\n",(0,n.jsx)(r.h3,{id:"graph-type",children:"Graph Type"}),"\n",(0,n.jsx)(r.p,{children:"A graph type is an entity on your object graph; a droid, a donut, a string, a number etc.  In GraphQL ASP.NET your model classes, interfaces, enums, controllers etc. are compiled into the various graph types required by the runtime."}),"\n",(0,n.jsx)(r.h3,{id:"query-document",children:"Query Document"}),"\n",(0,n.jsx)(r.p,{children:"This is the raw query text submitted by a client. When GraphQL accepts a query it is converted from a string to an internal document format that is parsed and used to fulfill the request."}),"\n",(0,n.jsxs)(r.blockquote,{children:["\n",(0,n.jsx)(r.p,{children:"Queries, Mutations and Subscriptions are all types of query documents."}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"root-graph-types",children:"Root Graph Types"}),"\n",(0,n.jsx)(r.p,{children:'There are three root graph types in GraphQL: Query, Mutation, Subscription. Whenever you make a graphql request, you always specify which query root you are targeting. This documentation will usually refer to all operations as "queries" but this includes mutations and subscriptions as well.'}),"\n",(0,n.jsx)(r.h3,{id:"schema",children:"Schema"}),"\n",(0,n.jsx)(r.p,{children:"This is the set of public data types, their fields, input arguments etc. that are exposed on an object graph. When you write a graphql query to return data, the fields you request must all be defined on a schema that graphql will validate your query against."}),"\n",(0,n.jsxs)(r.p,{children:['Your schema is "generated" at runtime by analyzing your model classes, controllers and action methods then populating a ',(0,n.jsx)(r.code,{children:"GraphSchema"})," container with the appropriate graph types to map graphql requests to your controllers."]}),"\n",(0,n.jsx)(r.admonition,{type:"note",children:(0,n.jsx)(r.p,{children:"In GraphQL ASP.NET the schema is generated at runtime directly from your C# controllers and POCOs; there is no additional boilerplate code necessary to define a schema."})})]})}function d(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}}}]);