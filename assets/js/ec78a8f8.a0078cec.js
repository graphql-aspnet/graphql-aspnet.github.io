"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1508],{3905:(e,t,o)=>{o.d(t,{Zo:()=>d,kt:()=>m});var n=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(o),h=r,m=c["".concat(s,".").concat(h)]||c[h]||u[h]||a;return o?n.createElement(m,i(i({ref:t},d),{},{components:o})):n.createElement(m,i({ref:t},d))}));function m(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=o.length,i=new Array(a);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<a;p++)i[p]=o[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}h.displayName="MDXCreateElement"},2767:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var n=o(7462),r=(o(7294),o(3905));const a={id:"made-for-aspnet-developers",title:"Made for ASP.NET Developers",sidebar_label:"Made for ASP.NET Developers",sidebar_position:1},i=void 0,l={unversionedId:"introduction/made-for-aspnet-developers",id:"introduction/made-for-aspnet-developers",title:"Made for ASP.NET Developers",description:"This library is designed by people who use ASP.NET in their day to day activities and is built for similar minded developers. When you first started digging in to GraphQL you most likely came across the plethora of articles, documents, tutorials and groups centered around JavaScript. JavaScript certainly has the highest adoption rate and with the tools provided by Apollo its no surprise. Its amazing how well those tools fit in with the existing knowledge and coding paradigms of JavaScript developers on both sides of the fence (be that front end or back end).",source:"@site/docs/introduction/made-for-aspnet-developers.md",sourceDirName:"introduction",slug:"/introduction/made-for-aspnet-developers",permalink:"/docs/introduction/made-for-aspnet-developers",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"made-for-aspnet-developers",title:"Made for ASP.NET Developers",sidebar_label:"Made for ASP.NET Developers",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"What is GraphQL?",permalink:"/docs/introduction/what-is-graphql"},next:{title:"Actions",permalink:"/docs/controllers/actions"}},s={},p=[{value:"Plays Nice with Web API Controllers, Razor Views and Razor Pages",id:"plays-nice-with-web-api-controllers-razor-views-and-razor-pages",level:2},{value:"Scoped Dependency Injection",id:"scoped-dependency-injection",level:2},{value:"User Authorization",id:"user-authorization",level:2},{value:"Custom Action Results",id:"custom-action-results",level:2}],d={toc:p};function c(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This library is designed by people who use ",(0,r.kt)("a",{parentName:"p",href:"https://dotnet.microsoft.com/en-us/apps/aspnet"},"ASP.NET")," in their day to day activities and is built for similar minded developers. When you first started digging in to GraphQL you most likely came across the plethora of ",(0,r.kt)("a",{parentName:"p",href:"https://www.graphqlweekly.com/"},"articles"),", ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/GraphQL"},"documents"),", ",(0,r.kt)("a",{parentName:"p",href:"https://www.howtographql.com/"},"tutorials")," and ",(0,r.kt)("a",{parentName:"p",href:"https://www.apollographql.com/"},"groups")," centered around JavaScript. JavaScript certainly has the highest adoption rate and with the tools provided by ",(0,r.kt)("a",{parentName:"p",href:"https://www.apollographql.com/"},"Apollo")," its no surprise. Its amazing how well those tools fit in with the existing knowledge and coding paradigms of JavaScript developers on both sides of the fence (be that front end or back end)."),(0,r.kt)("p",null,"We believe that tooling and workflow is everything when it comes to picking up a technology. Its much more difficult for you (or your team) to adopt something new if there is no connection to what you already know. Migrating your personal development efforts or an entire team from .NET to NodeJS to leverage Apollo Server, for instance, is hard. The learning curve and even the monetary cost of bringing a team up to speed is high. But if you can leverage existing skills you reduce that cost significantly."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"GraphQL ASP.NET aims to reuse your existing knowledge of ASP.NET")),(0,r.kt)("p",null,"This is a core, guiding principle for the development of this library. We aim to reuse what you know. Or if you are still learning, make what you learn transferable to other .NET technologies. When coming from a .NET background, being able to reason about your graph queries in terms of ",(0,r.kt)("inlineCode",{parentName:"p"},"Controllers")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Actions")," eases the cognitive load as you transition to thinking in terms of Fields and object graphs."),(0,r.kt)("p",null,"Using familiar concepts like ",(0,r.kt)("em",{parentName:"p"},"Binding Models")," and ",(0,r.kt)("em",{parentName:"p"},"View Models"),"; commonly used attributes like ",(0,r.kt)("inlineCode",{parentName:"p"},"[Authorize]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[Required]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[StringLength]"),"; modern ASP.NET's abstraction concepts like ",(0,r.kt)("inlineCode",{parentName:"p"},"IServiceCollection")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ILogger")," all play a part in hopes of giving you a familiar programming model that you can start using immediately without reinventing too many wheels."),(0,r.kt)("p",null,"Take, for instance, this controller and a sample query that would call it. Can you tell what it does? If you are familiar with Web API then the answer is probably yes!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="PersonController.cs"',title:'"PersonController.cs"'},'public class PersonController: GraphController\n{\n    private IPersonService _service;\n    public PersonController(IPersonService personService)\n    {\n        _service = personService;\n    }\n\n    [QueryRoot("person")]\n    public async Task<Person> RetrievePerson(int id)\n    {\n        return await _service.FetchPerson(id);\n    }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:'title="Sample Query"',title:'"Sample','Query"':!0},"query {\n    person(id: 5){\n        firstName\n        lastName\n        title\n    }\n}\n")),(0,r.kt)("p",null,"Another consideration when trying to implement GraphQL in .NET is the amount of boiler plate code required. Since C# is a strongly typed language the volume of additional coding required to generate an object graph tends to be high, especially in larger graphs. Many libraries take the approach of ultimate flexibility, requiring you to completely code your object graph, and all the fields that can be queried, and individually map all model properties and resolver methods manually. "),(0,r.kt)("p",null,"To address this, GraphQL ASP.NET has adopted an opinionated approach to its implementation. It makes some minor assumptions about how you will deliver your data in exchange for some much needed code generation and specification support. If the code in the controller above makes sense and feels natural to you; then this library might be worth a look. In terms of GraphQL, this single controller will:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Generate a fully qualified schema definition"),(0,r.kt)("li",{parentName:"ul"},"Provide introspection support"),(0,r.kt)("li",{parentName:"ul"},"Generate all required graph types (there are 17 in this example)")),(0,r.kt)("p",null,"The library will automatically wire up your graph controllers and scan your model objects. There is no additional, required configuration. When you add a new controller, new actions or new model properties they are automatically injected everywhere that object is used."),(0,r.kt)("p",null,"Are you working on a large project that has shared assemblies between services? No problem, you can direct GraphQL on where to look for controllers and model objects or even be explicit in what you want it to consume...down to the individual property level."),(0,r.kt)("admonition",{title:"You're in control",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"  Out of the box the library tries to pick the route of least resistance, but there are many ways to control what classes, enums etc. are included (or excluded) in your object graph. ")),(0,r.kt)("h2",{id:"plays-nice-with-web-api-controllers-razor-views-and-razor-pages"},"Plays Nice with Web API Controllers, Razor Views and Razor Pages"),(0,r.kt)("p",null,"This library sits as an extension on the standard ASP.NET pipeline, not a replacement. At its core, a graphql query is just another GET or POST route on your application. At startup it registers a middleware component to handle requests using ",(0,r.kt)("inlineCode",{parentName:"p"},"appBuilder.Map()"),"."),(0,r.kt)("p",null,"Also, if you are integrating into an existing project, you'll find a lot of your utility code should work out of the box which should ease your migration. Any existing services, custom authorization and model validation attributes etc. can be directly attached to graph action methods and input models. You might even find that most of your model objects work as well. "),(0,r.kt)("h2",{id:"scoped-dependency-injection"},"Scoped Dependency Injection"),(0,r.kt)("p",null,"Services are injected into graph controllers in the same manner as ASP.NET controllers and with the same scope resolutions."),(0,r.kt)("h2",{id:"user-authorization"},"User Authorization"),(0,r.kt)("p",null,"The user model is exactly the same. In fact, the ",(0,r.kt)("inlineCode",{parentName:"p"},"ClaimsPrincipal")," passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"this.User")," on a Web API controller is the same instance used to validate any ",(0,r.kt)("inlineCode",{parentName:"p"},"[Authorize]")," attributes on your graph controller actions. Internally, it uses the same ",(0,r.kt)("inlineCode",{parentName:"p"},"IAuthorizationService")," that gets added when you call ",(0,r.kt)("inlineCode",{parentName:"p"},"services.AddAuthorization()")," during startup."),(0,r.kt)("h2",{id:"custom-action-results"},"Custom Action Results"),(0,r.kt)("p",null,"Many teams define custom action results beyond ",(0,r.kt)("inlineCode",{parentName:"p"},"this.Ok()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"this.BadRequest()")," to standardize how they will respond to requests on their Web API controllers to provide consistent messaging, perform some sort of logging or create a common return payload. GraphQL ASP.NET supports this model as well. Out of the box you get support for many of the relevant action results around returning data, indicating an error or denying access, but you can implement your own ",(0,r.kt)("inlineCode",{parentName:"p"},"IGraphActionResult")," to standardize how a given result is converted into a response object and used by the runtime. This includes control to invalidate the field, inject customized error messages or cancel the field request altogether."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Side Note:")," Not all action results make sense in GraphQL. For instance, you won't find a way to download a file or indicate a 204 (no content) result. A GraphQL field must always return a piece of data (even if its null). Since the ",(0,r.kt)("inlineCode",{parentName:"p"},"IGraphActionResult")," object is only a small piece in an entire query of many fields, its scope of abilities is paired to match."))}c.isMDXComponent=!0}}]);