"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[8700],{7541:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"controllers/type-extensions","title":"Type Extensions","description":"Working with Child Data","source":"@site/docs/controllers/type-extensions.md","sourceDirName":"controllers","slug":"/controllers/type-extensions","permalink":"/docs/controllers/type-extensions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"type-extensions","title":"Type Extensions","sidebar_label":"Type Extensions","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Authorization","permalink":"/docs/controllers/authorization"},"next":{"title":"Batch Operations","permalink":"/docs/controllers/batch-operations"}}');var i=n(4848),a=n(8453);const s={id:"type-extensions",title:"Type Extensions",sidebar_label:"Type Extensions",sidebar_position:4},o=void 0,l={},d=[{value:"Working with Child Data",id:"working-with-child-data",level:2},{value:"The [TypeExtension] Attribute",id:"the-typeextension-attribute",level:2},{value:"\u2753 But what about the Bakery parameter?",id:"-but-what-about-the-bakery-parameter",level:4},{value:"Can Every Field be a Type Extension?",id:"can-every-field-be-a-type-extension",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h4:"h4",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"working-with-child-data",children:"Working with Child Data"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"The Motiviation for using Type Extensions"})}),"\n",(0,i.jsx)(t.p,{children:"Before we dive into type extensions we have to talk about parent-child relationships. So far, the examples we've seen have used well defined fields in an object graph. Be that an action method on a controller or a property on an object. But when we think about real world data, there are scenarios where that poses a problem. Lets suppose for a moment we have a chain of bakery stores that let customers place orders for cakes at an individual store and customize the writing on the cake."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="Sample Bakery Model"',children:"public class Bakery\n{\n    public int Id { get; set; }\n    // highlight-next-line\n    public List<CakeOrder> Orders { get; set; }\n}\n\npublic class CakeOrder\n{\n    public Customer Customer { get; set; }\n    public string  WrittenPhrase { get; set; }\n    // highlight-next-line\n    public Bakery Bakery { get; set; }\n}\n\n// ...Customer class excluded for brevity\n"})}),"\n",(0,i.jsx)(t.p,{children:"But consider the following scenarios:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["What happens when we retrieve a single ",(0,i.jsx)(t.code,{children:"CakeOrder"})," via a controller?"]}),"\n",(0,i.jsxs)(t.li,{children:["Do we automatically have to populate the entire ",(0,i.jsx)(t.code,{children:"Bakery"})," and ",(0,i.jsx)(t.code,{children:"Customer"})," objects?","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Even if a caller didn't request any of that data?"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.li,{children:"What happens when retrieving a bakery that may have 1000s of cake orders?"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Our application is going to slow to a crawl very quickly doing all this extra data loading. In the case of a single Bakery, a timeout may occur trying to fetch many years of cake orders to populate the bakery instance from a database query only to discard them when a graphql query doesn't ask for it. If we're using something like Entity Framework how do we know when to use an Include statement to populate the child data? (Hint: you don't)"}),"\n",(0,i.jsx)(t.p,{children:"One solution could be to use lazy loading on our model."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="Lazy Loading Child Data (Terrible!)"',children:"public class Bakery\n{\n\n    private ICakeService _service;\n    private Lazy<List<CakeOrder>> _orders;\n\n    public Bakery(int id, ICakeService service)\n    {\n        this.Id = id;\n        _service = service;\n        _orders = new Lazy<List<CakeOrder>>(this.RetrieveCakeOrders);\n    }\n\n    private List<CakeOrder> RetrieveCakeOrders()\n    {\n        return _service.RetrieveCakeOrders(this.Id);\n    }\n\n    public int Id { get; }\n    public List<CakeOrder> Orders => _orders.Value;\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Well that's just plain awful. We've over complicated our bakery model and made it dependent on a service instance to exist. If this was a real world example, you'd need some sort of error handling in there too."}),"\n",(0,i.jsx)(t.h2,{id:"the-typeextension-attribute",children:"The [TypeExtension] Attribute"}),"\n",(0,i.jsxs)(t.p,{children:["We've talked before about GraphQL maintaining a 1:1 mapping between a field in the graph and a method to retrieve data for it (i.e. its assigned resolver). What prevents us from creating a method to fetch a list of Cake Orders and saying, \"Hey, GraphQL! When someone asks for a set of bakery orders call a custom method instead of a property getter on the ",(0,i.jsx)(t.code,{children:"Bakery"}),' class." As it turns out, that is exactly what a ',(0,i.jsx)(t.code,{children:"Type Extension"})," does."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="Using a Type Extension"',children:'public class Bakery\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n\npublic class BakedGoodsCompanyController : GraphController\n{\n    [QueryRoot("bakery")]\n    public Bakery RetrieveBakery(int id){/*...*/}\n\n    // declare a extension to the Bakery object\n    // highlight-next-line\n    [TypeExtension(typeof(Bakery), "orders")]\n    public async Task<List<CakeOrder>> RetrieveCakeOrders(Bakery bakery, int limitTo = 15)\n    {\n        return await _service.RetrieveCakeOrders(bakery.Id, limitTo);\n    }\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Much Cleaner!!"}),"\n",(0,i.jsx)(t.p,{children:"There is a lot to unpack here, so lets step through it:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["We've declared the ",(0,i.jsx)(t.code,{children:"RetrieveBakery"})," method as a root field named ",(0,i.jsx)(t.code,{children:"bakery"})," that allows us to fetch a single bakery."]}),"\n",(0,i.jsxs)(t.li,{children:["We've added a method named ",(0,i.jsx)(t.code,{children:"RetrieveCakeOrders"}),", declared it as an ",(0,i.jsx)(t.em,{children:"extension"})," to the ",(0,i.jsx)(t.code,{children:"Bakery"})," object and gave it a field name of ",(0,i.jsx)(t.code,{children:"orders"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["The extension returns ",(0,i.jsx)(t.code,{children:"List<CakeOrder>"})," as the type of data it generates."]}),"\n",(0,i.jsxs)(t.li,{children:["The method takes in a ",(0,i.jsx)(t.code,{children:"Bakery"})," instance (more on that in a second) as well as an integer, with a default value of ",(0,i.jsx)(t.code,{children:"15"}),", to limit the number of orders to retrieve."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Now we can query the ",(0,i.jsx)(t.code,{children:"orders"})," field from anywhere a bakery is returned in the object graph and GraphQL will invoke our method:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-graphql",metastring:'title="Sample Query"',children:"query {\n    bakery(id: 5){\n        name\n        orders(limitTo: 50) {\n            id\n            writtenPhrase\n        }\n    }\n}\n"})}),"\n",(0,i.jsxs)(t.admonition,{type:"tip",children:[(0,i.jsx)(t.mdxAdmonitionTitle,{}),(0,i.jsxs)(t.p,{children:["Type Extensions allow you to attach new fields to a graph type without altering the original ",(0,i.jsx)(t.code,{children:"System.Type"}),"."]})]}),"\n",(0,i.jsx)(t.h4,{id:"-but-what-about-the-bakery-parameter",children:"\u2753 But what about the Bakery parameter?"}),"\n",(0,i.jsxs)(t.p,{children:["When we return a value from a property, an instance of an object must exist in order to supply that value. That is to say if you want the ",(0,i.jsx)(t.code,{children:"Name"})," property of a bakery, you need a bakery instance to retrieve it from.  The same is true for a ",(0,i.jsx)(t.code,{children:"type extension"})," except that instead of calling a property getter on the instance, graphql hands the entire object to your method and lets you figure out what needs to happen to resolve the field."]}),"\n",(0,i.jsxs)(t.p,{children:["GraphQL inspects the type being extended and finds a parameter on the method to match it. It captures that parameter, hides it from the object graph, and fills it with the result of the parent field, in this case the resolution of field ",(0,i.jsx)(t.code,{children:"bakery(id: 5)"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"This is immensely scalable:"}),"\n",(0,i.jsxs)(t.p,{children:["\u2705 There are no wasted cycles fetching ",(0,i.jsx)(t.code,{children:"CakeOrders"})," unless the requestor specifically asks for them.",(0,i.jsx)("br",{}),"\n\u2705 We have full access to ",(0,i.jsx)(t.a,{href:"../advanced/type-expressions",children:"type expression validation"})," and ",(0,i.jsx)(t.a,{href:"./model-state",children:"model validation"})," for our other method parameters.",(0,i.jsx)("br",{}),"\n\u2705Since its a controller action we have full access to graph action results and can return ",(0,i.jsx)(t.code,{children:"this.Ok()"}),", ",(0,i.jsx)(t.code,{children:"this.Error()"})," etc. to give a rich experience.",(0,i.jsx)("br",{}),"\n\u2705",(0,i.jsx)(t.a,{href:"./authorization",children:"Field Security"})," and use of the ",(0,i.jsx)(t.code,{children:"[Authorize]"})," attribute is also wired up for us. ",(0,i.jsx)("br",{}),"\n\u2705The bakery model is greatly simplified."]}),"\n",(0,i.jsx)(t.h2,{id:"can-every-field-be-a-type-extension",children:"Can Every Field be a Type Extension?"}),"\n",(0,i.jsx)(t.p,{children:"Theoretically, yes. But take a moment and think about performance. For basic objects with few dozen properties which is faster:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"Option 1:"})," One database query to retrieve 24 columns of a single record then only use six in a data result"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"Option 2:"})," Six separate database queries, one for each column requested."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Type extensions shine in parent-child relationships when preloading lots of data is a concern. But be careful not to isolate every graph field just to avoid retrieving extra data at all. Fetching a few extra bytes from a database is negligible compared to querying a database 20 individual times. Your REST APIs were already querying extra data and they were likely transmitting that data to the client."}),"\n",(0,i.jsxs)(t.p,{children:["It comes down to your use case. There are times when it makes sense to seperate things using type extensions and times when preloading whole objects is better. For many applications, once you've deployed to production, the queries being executed are finite. Design your model objects and extensions to be performant in the ways your data is being requested, not in the ways it ",(0,i.jsx)(t.em,{children:"could be"})," requested."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var r=n(6540);const i={},a=r.createContext(i);function s(e){const t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);